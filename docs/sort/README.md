# 排序算法

最经典、常用的排序算法：

时间复杂度为 O(n ^ 2)，不基于比较:

- 冒泡排序
- 插入排序
- 选择排序

插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？

时间复杂度为 O(logn)，不基于比较:

- 归并排序
- 快速排序

时间复杂度为 O(n)，不基于比较:

- 计数排序
- 基数排序
- 桶排序


## 如何分析排序算法

对于排序算法的执行效率，一般会从以下几个方面来分析。

### 执行效率 - 时间复杂度（最好、最坏、平均）

1. 最好情况、最坏情况、平均情况时间复杂度

要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。

为什么要区分这三种时间复杂度？

- 为了好对比
- 排序算法在不同数据下的性能表现
  - 对于要排序的数据，有的接近有序，有的完全无序
  - 有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现

1. 时间复杂度的系数、常数 、低阶

对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。

虽然时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据。

2. 比较次数和交换（或移动）次数

基于比较的排序算法的执行过程，会涉及两种操作：

- 一种是元素比较大小
- 另一种是元素交换或移动

所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。

### 内存消耗 - 空间复杂度（原地排序）

我们讲过，算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。

针对排序算法的空间复杂度，我们还引入了一个新的概念，**原地排序**（Sorted in place），用于特指空间复杂度是 O(1) 的排序算法。

冒泡排序、插入排序、选择排序都是原地排序算法。

### 稳定性 - 顺序不变

针对排序算法，还有一个重要的度量指标，稳定性。

如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

那么为什么要考察排序算法的稳定性呢？

> 很多数据结构和算法课程，在讲排序的时候，都是用整数来举例，但在真正软件开发中，我们要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个 key 来排序。

以电商交易系统中的“订单”排序为例。订单有两个属性

- 下单时间
- 订单金额

现在有 10 万条订单数据，我们希望：

1. 按照金额从小到大对订单数据排序
2. 金额相同的订单，按照下单时间从早到晚排序

怎么做？

最先想到的方法是：

- 先按照金额对订单数据进行排序
- 再遍历排序之后的订单数据，对于每个金额相同的订单按照下单时间排序

这种排序思路理解起来不难，但是实现起来会很复杂。而借助稳定排序算法，这个问题可以非常简洁地解决。

解决思路：

- 先按照下单时间给订单排序，注意是按照下单时间，不是金额
- 排序完成之后，我们用稳定排序算法，按照订单金额重新排序。

两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。为什么呢？

稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。

- 第一次排序之后，所有的订单按照下单时间从早到晚有序了
- 在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。

![稳定性](@imgs/1381c1f3f7819ae61ab17455ed7f0b59.jpg)

想想这两种处理方式的区别是什么：第二种算法不会在第一步排序时遇到值相同的情况，所以排序就非常简单，第二步通过稳定的排序算法再调整；而第一种方式恰好相反
。
