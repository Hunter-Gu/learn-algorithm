# 优化排序算法

如何实现一个**通用的、高性能**的排序函数？

## 如何选择合适的排序算法？

如果要实现一个**通用的、高效率**的排序函数，我们应该选择哪种排序算法？

![各排序算法比较](@imgs/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg)

线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法。

- 小规模数据：可以选择时间复杂度是 O(n^2) 的算法
- 大规模数据：时间复杂度是 O(n * logn) 的算法更加高效

所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。时间复杂度是 O(nlogn) 的排序算法不止一个，我们已经讲过的有归并排序、快速排序，后面讲堆的时候我们还会讲到堆排序。

使用归并排序的情况其实并不多。虽然快排在最坏情况下的时间复杂度是 O(n^2)，而归并排序可以做到平均情况、最坏情况下的时间复杂度都是 O(nlogn)，从这点上看起来很诱人，但是归并排序并不是原地排序算法，且空间复杂度是 O(n)。

快速排序比较适合来实现排序函数，但是，我们也知道，快速排序在最坏情况下的时间复杂度是 O(n^2)，如何来解决这个“复杂度恶化”的问题呢？

## 快排优化

先来看下，为什么最坏情况下快速排序的时间复杂度是 O(n^2) 呢？

如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为 O(n^2)。实际上，这种 O(n^2) 时间复杂度出现的主要原因还是因为我们分区点选的不够合理。

那什么样的分区点是好的分区点呢？或者说如何来选择分区点呢？

最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。如果很粗暴地直接选择第一个或者最后一个数据作为分区点，不考虑数据的特点，肯定会出现排序的最坏情况时间复杂度 O(n^2)。为了提高排序算法的性能，我们也要尽可能地让每次分区都比较平均。

### 三数取中法

从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。

这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是**不适合要排序的数组比较大的情况**，这时候可能要“五数取中”或者“十数取中”。

### 随机法

随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选的很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n^2) 的情况，出现的可能性不大。

如果想了解更多寻找分区点的方法，你可以自己深入学习一下。

我们知道，快速排序是用递归来实现的。我们在递归那一节讲过，递归要警惕堆栈溢出。为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，我们有两种解决办法：

- 第一种是限制递归深度。一旦递归过深，超过了我们事先设定的阈值，就停止递归
- 第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制

## 举例分析排序函数

以 Glibc 中的 `qsort()` 函数举例，内部使用了多种排序算法：

优先使用归并排序。因为归并排序的空间复杂度是 O(n)，所以对于小数据量的排序，比如 1KB、2KB 等，归并排序额外需要 1KB、2KB 的内存空间，这个问题不大。现在计算机的内存都挺大的，我们很多时候追求的是速度，这是典型的用空间换时间。

但如果数据量太大，比如排序 100MB 的数据，再用归并排序就不合适了，这个时候会改为用快速排序算法来排序。那么如何选择快速排序算法的分区点的呢？`qsort()` 选择分区点的方法就是“三数取中法”。

实际上，`qsort()` 并不仅仅用到了归并排序和快速排序，它还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，`qsort()` 就退化为插入排序，不再继续用递归来做快速排序。

因为，在小规模数据面前，O(n^2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。这是为什么呢？

时间复杂度代表的是一个增长趋势，如果画成增长曲线图，你会发现 O(n^2) 比 O(nlogn) 要陡峭，也就是说增长趋势要更猛一些。但是大 O 复杂度表示法省略了低阶、系数和常数，也就是说 O(nlogn) 在没有省略低阶、系数、常数之前可能是 O(k * nlogn + c)，而且 k 和 c 有可能还是一个比较大的数。

所以，对于小规模数据的排序，O(n^2) 的排序算法并不一定比 O(nlogn) 排序算法执行的时间长。对于小数据量的排序，我们选择比较简单、不需要递归的插入排序算法。
