# 插入排序

先看一个问题：一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数组有序呢？

只要遍历数组，找到数据应该插入的位置将其插入即可。

这是一个动态排序的过程，即动态地往有序集合中添加数据，我们可以通过这种方法保持集合中的数据一直有序。而对于一组静态数据，也可以借鉴上面讲的插入方法，来进行排序，于是就有了插入排序算法。

## 已排区间 & 未排区间

那插入排序具体是如何借助上面的思想来实现排序的呢？

- 首先，我们将数组中的数据分为两个区间
  - 已排序区间
  - 未排序区间
- 初始已排序区间只有一个元素，就是数组的第一个元素

插入算法的核心思想是**取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入**，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

如图所示，要排序的数据是 4，5，6，1，3，2 其中左侧为已排序区间，右侧是未排序区间：

![插入排序](@imgs/b60f61ec487358ac037bf2b6974d2de1.jpg)

插入排序包含两种操作：

- 元素的比较
- 元素的移动

当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。

找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。

对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。

```ts
function insertionSort(arr: number[]) {
  // 遍历未排区间
  for (let i = 1; i < arr.length; i++) {
    // 需要插入的元素
    const tmp = arr[i]
    // 反向遍历已排区间
    let j = i - 1
    for (; j >= 0; j--) {
      // 比较 + 换位操作
      if (arr[j] > tmp) {
        arr[j + 1] = arr[j]
      } else {
        // 前面的已经排好
        break
      }
    }
    arr[j + 1] = tmp
  }

  return arr
}
```

## 性能分析

### 原地排序

从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。

### 稳定性

在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。

### 时间复杂度

- 最好情况：要排序的数据是有序的，每次只需要比较一个数据就能确定插入的位置，时间复杂度为 O(n)
- 最坏情况：要排序的数据是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n^2)。
- 平均情况：在数组中插入一个数据的平均时间复杂度是 O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n^2)

## 思考

为什么插入排序要比冒泡排序更受欢迎呢？

我们前面分析冒泡排序和插入排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。

我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。

- 用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。
- 而插入排序中数据移动操作只需要 K 个单位时间。

所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n^2)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。插入排序的算法思路也有很大的优化空间，我们只是讲了最基础的一种。如果你对插入排序的优化感兴趣，可以自行学习一下希尔排序。

## 希尔排序

TODO
