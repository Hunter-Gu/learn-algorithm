# 选择排序

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

![选择排序](@imgs/32371475a0b08f0db9861d102474181d.jpg)

## 性能分析

### 原地排序

选择排序空间复杂度为 O(1)，是一种原地排序算法。

### 稳定性

选择排序是一种不稳定的排序算法。

![选择排序](@imgs/32371475a0b08f0db9861d102474181d.jpg)

选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。

比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。

这也是为什么，相对于冒泡排序和插入排序，选择排序就稍微逊色了。

### 时间复杂度

- 最好情况：O(n^2)
- 最差情况：O(n^2)
- 平均情况：O(n^2)

TODO 分析过程

## 链表实现

TODO

都是基于数组实现的。如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？

对于老师所提课后题，觉得应该有个前提，是否允许修改链表的节点value值，还是只能改变节点的位置。一般而言，考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；选择排序比较次数一致，交换操作同样比较麻烦。综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。
