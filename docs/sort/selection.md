# 选择排序

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

![选择排序](@imgs/32371475a0b08f0db9861d102474181d.jpg)

```ts
function selectionSort(arr: number[]) {
  for (let i = 0; i < arr.length; i++) {
    let minIndex = i
    for (let j = i; j < arr.length; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j
      }
    }
    const tmp = arr[i]
    arr[i] = arr[minIndex]
    arr[minIndex] = tmp
  }
  return arr
}
```

## 性能分析

### 原地排序

选择排序空间复杂度为 O(1)，是一种原地排序算法。

### 稳定性

选择排序是一种不稳定的排序算法。

![选择排序](@imgs/32371475a0b08f0db9861d102474181d.jpg)

选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。

比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。

这也是为什么，相对于冒泡排序和插入排序，选择排序就稍微逊色了。

### 时间复杂度

- 最好情况：O(n^2)
- 最差情况：O(n^2)
- 平均情况：O(n^2)

选择排序在所有情况下，都是一样的表现。找出最小值的时间复杂度为 O(n)，需要执行 n 次，所以任何情况下的时间复杂度都是 O(n^2)。
