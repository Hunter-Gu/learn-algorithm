# 选择排序

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

核心：**找到数组中最小的元素，将它和数组的第一个元素交换位置；再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。**

> 交换元素的代码写在循环内，所以交换的总次数是 N，所以算法的时间效率取决于比较大次数。

> 选择排序大约需要 N ^ 2 / 2 次比较和 N 次交换。

![选择排序](@imgs/32371475a0b08f0db9861d102474181d.jpg)

<<< @/docs/sort/code/selection.ts

<<< @/docs/sort/code/selection.c

## 性能分析

### 原地排序

选择排序空间复杂度为 O(1)，是一种原地排序算法。

### 稳定性

选择排序是一种不稳定的排序算法。

![选择排序](@imgs/32371475a0b08f0db9861d102474181d.jpg)

选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。

比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。

这也是为什么，相对于冒泡排序和插入排序，选择排序就稍微逊色了。

### 时间复杂度

- 最好情况：O(n^2)
- 最差情况：O(n^2)
- 平均情况：O(n^2)

选择排序在所有情况下，都是一样的表现。找出最小值的时间复杂度为 O(n)，需要执行 n 次，所以任何情况下的时间复杂度都是 O(n^2)。

## 特点

- 选择排序的**运行时间和输入无关**
	- 为了找出最小元素而扫描一遍数组，并不能为下一遍扫描提供什么信息
- 数据移动是最少的
	- 每次交换都会改变两个数组元素的值，一共 N 次（交换次数和数组大小是线性关系）
