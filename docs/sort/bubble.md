# 冒泡排序

## 冒泡操作

遍历序列，对**相邻**的两个元素进行比较，根据结果决定是否互换位置。

一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作，即冒泡排序。

通过一个例子，看下冒泡排序的整个过程。我们要对一组数据 4，5，6，3，2，1 从小到大进行排序。第一次冒泡操作的详细过程就是这样：

![一次冒泡操作](@imgs/4038f64f47975ab9f519e4f739e464e9.jpg)

可以看出，经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。

这个冒泡过程可以优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。

TODO 冒泡排序算法代码

## 性能分析

### 原地排序

冒泡排序是原地排序算法。

冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。

### 稳定性

冒泡排序是稳定的排序算法。

在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。

### 时间复杂度

- 最好情况：要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。
- 而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n^2)。

### 平均情况时间复杂度 - 有序度 & 逆序度

那平均情况下的时间复杂是多少呢？

我们前面讲过，平均时间复杂度就是加权平均期望时间复杂度，分析的时候要结合概率论的知识。

对于包含 n 个数据的数组，这 n 个数据就有 n! 种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。我这里还有一种思路，通过“有序度”和“逆序度”这两个概念来进行分析。

#### 有序度

数组中具有**有序关系的元素对**的个数。有序元素对用数学表达式表示就是这样：

```
有序元素对：a[i] <= a[j], 如果 i < j。
```

![有序度](@imgs/a1ef4cc1999d6bd0af08d8417ee55220.jpg)

同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 n*(n-1)/2，也就是 15。

把完全有序的数组的有序度叫作**满有序度**。

#### 逆序度

逆序度的定义正好跟有序度相反（默认从小到大为有序）:

```
逆序元素对：a[i] > a[j], 如果 i < j。
```

我们可以得到一个公式：

```
逆序度 = 满有序度 - 有序度
```

排序的过程就是**一种增加有序度，减少逆序度的过程**，最后达到满有序度，就说明排序完成了。

冒泡排序包含两个操作原子，比较和交换。**每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的**。

#### 平均情况时间复杂度

对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？

- 最坏情况：初始状态的有序度是 0，所以要进行 n*(n-1)/2 次交换
- 最好情况：初始状态的有序度是 n*(n-1)/2，就不需要进行交换
- 平均情况：取中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的情况

也就是说平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n^2)，所以平均情况下的时间复杂度就是 O(n^2)。

这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太复杂，不太好用。

## 链表实现

TODO

都是基于数组实现的。如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？

对于老师所提课后题，觉得应该有个前提，是否允许修改链表的节点value值，还是只能改变节点的位置。一般而言，考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；选择排序比较次数一致，交换操作同样比较麻烦。综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。
