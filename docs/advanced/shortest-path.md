# 最短路径

深度优先搜索和广度优先搜索主要是针对无权图的搜索算法。

针对有权图，也就是图中的每条边都有一个权重，该如何计算两点之间的最短路径（经过的边的权重和最小）呢？

## 算法解析

定义如下三个最优问题：

- 最短路线
- 最少用时
- 最少红绿灯

先解决最短路线，把地图抽象成图：

- 把每个岔路口看作一个顶点，岔路口与岔路口之间的路看作一条边，路的长度就是边的权重
- 如果路是单行道，就在两个顶点之间画一条有向边
- 如果路是双行道，就在两个顶点之间画两条方向不同的边

这样，整个地图就被抽象成一个有向有权图，于是求解的问题就转化为，在一个有向有权图中，求两个顶点间的最短路径：

<!-- TODO -->

（单源）最短路径算法（一个顶点到一个顶点）是解决该问题的经典算法。

## Dijkstra 算法

最出名的最短路径算法莫过于 Dijkstra 算法了。

<!-- TODO 代码 -->

![](@imgs/e20907173c458fac741e556c947bb9a9.jpg)

### 时间复杂度

整个代码的时间复杂度就是 O(E*logV)。

从理论上讲，用 Dijkstra 算法可以计算出两点之间的最短路径。但是，对于一个超级大地图来说，岔路口、道路都非常多，对应到图这种数据结构上来说，就有非常多的顶点和边。如果为了计算两点之间的最短路径，在一个超级大图上动用 Dijkstra 算法，遍历所有的顶点和边，显然会非常耗时。

做工程不像做理论，一定要给出个最优解。理论上算法再好，如果执行效率太低，也无法应用到实际的工程中。对于软件开发工程师来说，经常要根据问题的实际背景，对解决方案权衡取舍。类似出行路线这种工程上的问题，没有必要非得求出个绝对最优解。很多时候，为了兼顾执行效率，只需要计算出一个可行的次优解就可以了。

虽然地图很大，但是两点之间的最短路径或者说较好的出行路径，并不会很“发散”，只会出现在两点之间和两点附近的区块内：

- 所以可以在整个大地图上，划出一个小的区块，这个小区块恰好可以覆盖住两个点，但又不会很大
- 只需要在这个小区块内部运行 Dijkstra 算法，这样就可以避免遍历整个大图，也就大大提高了执行效率

你可能会说了，如果两点距离比较远，从北京海淀区某个地点，到上海黄浦区某个地点，那上面的这种处理方法，显然就不工作了，毕竟覆盖北京和上海的区块并不小。这里给你点提示，你可以现在打开地图 App，缩小放大一下地图，看下地图上的路线有什么变化，然后再思考，这个问题该怎么解决。对于这样两点之间距离较远的路线规划，可以把北京海淀区或者北京看作一个顶点，把上海黄浦区或者上海看作一个顶点，先规划大的出行路线。比如，如何从北京到上海，必须要经过某几个顶点，或者某几条干道，然后再细化每个阶段的小路线。

最短路径问题就解决了，再来看另外两个问题，最少时间和最少红绿灯。

讲最短路径的时候，每条边的权重是路的长度。在计算最少时间的时候，算法还是不变，只需要把边的权重，从路的长度变成经过这段路所需要的时间。不过，这个时间会根据拥堵情况时刻变化。

如何计算车通过一段路的时间呢？

每经过一条边，就要经过一个红绿灯。关于最少红绿灯的出行方案，只需要把每条边的权值改为 1 即可，算法还是不变，可以继续使用前面讲的 Dijkstra 算法。

不过，边的权值为 1，也就相当于无权图了，还可以使用之前讲过的广度优先搜索算法。因为前面讲过，广度优先搜索算法计算出来的两点之间的路径，就是两点的最短路径。

不过，这里给出的所有方案都非常粗糙，只是为了给你展示，如何结合实际的场景，灵活地应用算法，让算法为我们所用，真实的地图软件的路径规划，要比这个复杂很多。

而且，比起 Dijkstra 算法，地图软件用的更多的是类似 A* 的启发式搜索算法，不过也是在 Dijkstra 算法上的优化罢了。

## 总结

除了 Dijkstra 算法，最短路径算法还有很多，比如 Bellford 算法、Floyd 算法等等。

这些算法实现思路非常经典，掌握了这些思路，可以拿来指导、解决其他问题。

比如 Dijkstra 这个算法的核心思想，就可以拿来解决下面这个看似完全不相关的问题。

有一个翻译系统，只能针对单个词来做翻译。如果要翻译一整个句子，我们需要将句子拆成一个一个的单词，再丢给翻译系统。针对每个单词，翻译系统会返回一组可选的翻译列表，并且针对每个翻译打一个分，表示这个翻译的可信程度。

![](@imgs/91b68e47e0d8521cb3ce66bb9827c767.jpg)

针对每个单词，从可选列表中选择其中一个翻译，组合起来就是整个句子的翻译。每个单词的翻译的得分之和，就是整个句子的翻译得分。随意搭配单词的翻译，会得到一个句子的不同翻译。针对整个句子，我们希望计算出得分最高的前 k 个翻译结果，你会怎么编程来实现呢？

![](@imgs/769cab20f6a50c0b7a4ed571c9f28a53.jpg)

最简单的办法还是借助回溯算法，穷举所有的排列组合情况，然后选出得分最高的前 k 个翻译结果。但是，这样做的时间复杂度会比较高，是 O(m^n)，其中，m 表示平均每个单词的可选翻译个数，n 表示一个句子中包含多少个单词。这个解决方案，你可以当作回溯算法的练习题，自己编程实现一下，我就不多说了。

实际上，这个问题可以借助 Dijkstra 算法的核心思想，非常高效地解决。每个单词的可选翻译是按照分数从大到小排列的，所以 a0​b0​c0​ 肯定是得分最高组合结果。我们把 a0​b0​c0​ 及得分作为一个对象，放入到优先级队列中。

我们每次从优先级队列中取出一个得分最高的组合，并基于这个组合进行扩展。扩展的策略是每个单词的翻译分别替换成下一个单词的翻译。比如 a0​b0​c0​ 扩展后，会得到三个组合，a1​b0​c0​、a0​b1​c0​、a0​b0​c1​。我们把扩展之后的组合，加到优先级队列中。重复这个过程，直到获取到 k 个翻译组合或者队列为空。

![](@imgs/e71f307ca575d364ba2b23a022779f6c.jpg)

我们来看，这种实现思路的时间复杂度是多少？假设句子包含 n 个单词，每个单词平均有 m 个可选的翻译，我们求得分最高的前 k 个组合结果。每次一个组合出队列，就对应着一个组合结果，我们希望得到 k 个，那就对应着 k 次出队操作。每次有一个组合出队列，就有 n 个组合入队列。优先级队列中出队和入队操作的时间复杂度都是 O(logX)，X 表示队列中的组合个数。所以，总的时间复杂度就是 O(k*n*logX)。那 X 到底是多少呢？k 次出入队列，队列中的总数据不会超过 k*n，也就是说，出队、入队操作的时间复杂度是 O(log(k*n))。所以，总的时间复杂度就是 O(k*n*log(k*n))，比之前的指数级时间复杂度降低了很多。

## 思考

1.在计算最短时间的出行路线中，如何获得通过某条路的时间呢？这个题目很有意思，我之前面试的时候也被问到过，你可以思考看看。

答：1.获取通过某条路的时间：通过某条路的时间与①路长度②路况(是否平坦等)③拥堵情况④红绿灯个数等因素相关。获取这些因素后就可以建立一个回归模型(比如线性回归)来估算时间。其中①②④因素比较固定，容易获得。③是动态的，但也可以通过a.与交通部门合作获得路段拥堵情况；b.联合其他导航软件获得在该路段的在线人数；c.通过现在时间段正好在次路段的其他用户的真实情况等方式估算。

2.今天讲的出行路线问题，我假设的是开车出行，那如果是公交出行呢？如果混合地铁、公交、步行，又该如何规划路线呢？

答：2.混合公交、地铁和步行时：地铁时刻表是固定的，容易估算。公交虽然没那么准时，大致时间是可以估计的，步行时间受路拥堵状况小，基本与道路长度成正比，也容易估算。总之，感觉公交、地铁、步行，时间估算会比开车更容易，也更准确些。
