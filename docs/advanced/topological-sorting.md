# 拓扑排序

## 如何确定代码源文件的编译依赖关系

一个完整的项目往往会包含很多代码源文件。编译器在编译整个项目的时候，需要按照依赖关系，依次编译每个源文件。

比如，A.cpp 依赖 B.cpp，那在编译的时候，编译器需要先编译 B.cpp，才能编译 A.cpp。编译器通过分析源文件或者程序员事先写好的编译配置文件（比如 Makefile 文件），来获取这种局部的依赖关系。

那编译器又该如何通过源文件两两之间的局部依赖关系，确定一个全局的编译顺序呢？

![文件依赖关系](@imgs/5247b6639e98419a1963cecd8f12713b.jpg)

## 算法分析

通过与“图”这种数据结构相关的拓扑排序可以解决这个问题。

拓扑排序问题表示两两之间有依赖关系，比如你必须先穿袜子才能穿鞋。

接下来就要将问题抽象成具体的数据结构了：

- 把源文件与源文件之间的依赖关系，抽象成一个有向图
- 每个源文件对应图中的一个顶点，源文件之间的依赖关系就是顶点之间的边

如果 b 依赖于 a，就构建一条从 a 指向 b 的边。

**这个图不仅要是有向图，还要是一个有向无环图**（不能存在像 a->b->c->a 这样的循环依赖关系）。**图中一旦出现环，拓扑排序就无法工作**。

接下来具体实现拓扑排序算法。

### Kahn 算法

Kahn 算法的本质是贪心算法思想：

- 定义数据结构时，如果 s 先于 t 执行，则添加一条 s 指向 t 的边
- 如果某个顶点入度为 0， 就表示没有任何顶点必须先于这个顶点执行，那么这个顶点就可以执行了
- 从图中找出一个入度为 0 的顶点，将其输出到拓扑排序的结果序列中，并且把这个顶点从图中删除
- 循环上述过程，直到所有的顶点都被输出
- ...
- 最后输出的序列，就是满足局部依赖关系的拓扑排序

<!-- TODO 代码 -->

### DFS 深度优先搜索算法

拓扑排序也可以用深度优先遍历来实现，遍历图中的所有顶点，而非只是搜索一个顶点到另一个顶点的路径。

该算法包含两个关键部分：

- 通过邻接表构造逆邻接表
-递归处理每个顶点，这是这个算法的核心

### 复杂度

Kahn 算法中每个顶点被访问一次，每条边也都被访问了一次，所以时间复杂度就是 O(V+E)（V 表示顶点个数，E 表示边的个数）。

DFS 算法中每个顶点被访问两次，每条边都被访问一次，所以时间复杂度也是 O(V+E)（V 表示顶点个数，E 表示边的个数）。

注意，这里的图可能不是连通的，有可能是有好几个不连通的子图构成，所以，E 并不一定大于 V，两者的大小关系不确定。所以，在表示时间复杂度的时候，V、E 都要考虑在内。

## 总结

凡是需要通过局部顺序来推导全局顺序的，一般都能用拓扑排序来解决。

除此之外，拓扑排序还能检测图中环的存在。对于 Kahn 算法来说，如果最后输出的顶点个数，少于图中顶点个数，图中还有入度不是 0 的顶点，就说明图中存在环。

关于图中环的检测，我们在递归那一节讲过一个例子，在查找最终推荐人的时候，可能会因为脏数据，造成存在循环推荐，比如，用户 A 推荐了用户 B，用户 B 推荐了用户 C，用户 C 又推荐了用户 A。如何避免这种脏数据导致的无限递归？这个问题，我当时留给你思考了，现在是时候解答了。

实际上，这就是环的检测问题。因为我们每次都只是查找一个用户的最终推荐人，所以，我们并不需要动用复杂的拓扑排序算法，而只需要记录已经访问过的用户 ID，当用户 ID 第二次被访问的时候，就说明存在环，也就说明存在脏数据。

```java
HashSet<Integer> hashTable = new HashSet<>(); // 保存已经访问过的actorId
long findRootReferrerId(long actorId) {
  if (hashTable.contains(actorId)) { // 存在环
    return;
  }
  hashTable.add(actorId);
  Long referrerId =
       select referrer_id from [table] where actor_id = actorId;
  if (referrerId == null) return actorId;
  return findRootReferrerId(referrerId);
}
```

如果把这个问题改一下，我们想要知道，数据库中的所有用户之间的推荐关系了，有没有存在环的情况。这个问题，就需要用到拓扑排序算法了。我们把用户之间的推荐关系，从数据库中加载到内存中，然后构建成今天讲的这种有向图数据结构，再利用拓扑排序，就可以快速检测出是否存在环了。

## 思考

1.在今天的讲解中，我们用图表示依赖关系的时候，如果 a 先于 b 执行，我们就画一条从 a 到 b 的有向边；反过来，如果 a 先于 b，我们画一条从 b 到 a 的有向边，表示 b 依赖 a，那今天讲的 Kahn 算法和 DFS 算法还能否正确工作呢？如果不能，应该如何改造一下呢？

答：1. a先于b执行，也就说b依赖于a，b指向a，这样构建有向无环图时，要找到出度为0的顶点，然后删除

2.我们今天讲了两种拓扑排序算法的实现思路，Kahn 算法和 DFS 深度优先搜索算法，如果换做 BFS 广度优先搜索算法，还可以实现吗？

答：2. BFS也能实现，因为遍历只是实现拓扑排序的一个“辅助手段”，本质上是帮助找到优先执行的顶点
