# 数组

几乎每种编程语言中，都会有数组这种数据类型；数组也是一种最基础的数据结构。

## 随机访问 - 连续内存空间 & 相同类型数据

数组是**一种[线性表结构](list.html#线性表)，用一组_连续_的内存空间，来存储一组_相同类型_的数据**。所以数组在**定义时，需要预先指定大小**。

**连续的内存空间和相同类型的数据**，使得我们可以通过下标**随机访问**其中的元素（数组的最大特点是随机访问）。

但是有利就有弊，这两个限制也使得数组的很多操作变得低效，比如在数组中插入、删除数据，为了保证连续性，需要做大量的数据搬移工作。

那么数组是如何实现根据下标随机访问数组元素的呢？

![例子](@imgs/98df8e702b14096e7ee4a5141260cdc4.jpg)

以长度为 10 的 int 类型数组为例，计算机会给该数组分配一块连续的内存空间，假设首地址为 base_address = 1000，int 类型占用 4byte 即 data_type_size = 4，所以我们可以得到寻址公式：

```
a[i]_address = base_address + i * data_type_size
```

所以下标从 0 开始就可以避免每次访问数组元素都执行减一运算，并且**下标的含义可以理解为偏移（offset）**。

## 低效的插入和删除

### 插入

![数组的插入](@imgs/th.jpeg)

假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。

那插入操作的时间复杂度是多少呢？

- 最好情况时间复杂度：插入的位置刚好是数组的末尾，时间复杂度为 O(1)
- 最差情况时间复杂度：插入的位置刚好是数组的头部，时间复杂度为 O(n)，n 为数组的长度
- 平均情况时间复杂度：(n + 1)/2 即 O(n)

当然，我们可以在位置 k 插入时，把该位置的元素搬移到数组的末尾，从而避免大规模的数据搬移，此时插入操作的时间复杂度则为 O(1)：

![插入时将原数据搬移到末尾](@imgs/3f70b4ad9069ec568a2caaddc231b7dc.jpg)

这其实就是快排的思想！

### 删除

和插入数据类似，如果要删除第 k 个位置的数据，为了内存的连续性，也要搬移数据使得内存连续。

所以删除操作的时间复杂度和插入操作类似：

- 最好情况时间复杂度：删除的位置刚好是数组的末尾，时间复杂度为 O(1)
- 最差情况时间复杂度：删除的位置刚好是数组的头部，时间复杂度为 O(n)，n 为数组的长度
- 平均情况时间复杂度：(n + 1)/2 即 O(n)

在某些特殊场景下，并不一定非得追求数组中数据的连续性，可以把多次删除操作集中在一起，这样删除的效率是不是可以提高很多？

![删除时只是记录](@imgs/b69b8c5dbf6248649ddab7d3e7cfd7e5.jpg)

举个例子，数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。

为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据，每次的**删除操作并不是真正地搬移数据，只是记录数据已经被删除**。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。

这其实是 JVM 标记清除垃圾回收算法的核心思想。

## 越界索引

在 C 语言中，只要不是访问受限内存，所有的内存空间都是可以自由访问的，所以按照之前的寻址公式，就会被定位到某块不属于数组的内存地址上。

而 Java 本身会做越界索引检查，所以就会抛出错误。

## 容器（动态数组）

很多语言对数组类型提供了容器类（动态数组），如 Java 中的 `ArrayList`，实际开发时，什么时候适合用数组，什么时候适合用容器呢？

以 Java 的 `ArrayList` 为例，它的优势是：

- **将很多数组操作的细节封装了起来**
- **支持动态扩容**

为了分配连续的内存空间，数组在定义时需要预先指定大小。所以如果一个数组的长度为 10，当第 11 个数据需要插入到数组中时，就需要重新分配一块更大的空间，将原来的数据复制过去，然后插入新的数据。

而使用 `ArrayList` 就不需要关心底层的扩容逻辑，每次存储空间不够，他都会将空间自动扩容为 1.5 倍大小。

:::tip
注意，扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 `ArrayList` 的时候事先指定数据大小。
:::

举个例子：

```java
ArrayList users = new ArrayList(10000);

for (int i = 0; i < 10000; ++i) {
  users.add(xxx);
}
```

事先指定数据大小可以省掉很多次内存申请和数据搬移操作。

那么 `ArrayList` 就一定比 `Array` 好了吗？

- `ArrayList` 无法存储基本类型，如 `int`, `long`，需要封装为 `Integer`, `Long`，自动装箱、拆箱也有一定的性能消耗，所以如果特别关注性能，就可以使用 `Array`
- 如果数据大小事先已知，并且对数据的操作非常简单，用不到 `ArrayList` 提供的大部分方法，也可以直接使用 `Array`
- 对于业务开发，直接使用 `ArrayList` 就行了，省时省力；如果是做一些底层开发，这时候优先使用 `Array`

## 思考

- **前面讲过一维数组的内存寻址公式，思考一下，二维数组的内存寻址公式是怎样的呢？**

对于 m * n 的数组，`a[i][j]` (i < m, j < n) 的地址为：

```
address = base_address + ( i * n + j) * type_size
```
