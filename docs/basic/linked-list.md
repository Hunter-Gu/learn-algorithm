# 链表

## 链表 vs 数组

先从底层的存储结构上来看一看。

![数组 vs 链表](@imgs/d5d5bee4be28326ba3c28373808a62cd.jpg)

数组需要一块连续的内存空间来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。

而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。

我们先介绍三种最常见的链表结构：

- 单链表
- 双向链表
- 循环链表

## 单链表

![单链表](@imgs/b93e7ade9bb927baad1348d9a806ddeb.jpg)

单链表有几个重要的概念：

- 结点：链表通过指针将一组零散的内存块串联在一起，该内存块称为链表的“结点”
- 后继指针（next）：为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址，这个记录下个结点地址的指针叫作后继指针
- 头结点：第一个结点，用来记录链表的基地址，通过该结点可以遍历得到整条链表
- 尾结点：最后一个结点，指向一个空地址 NULL，表示这是链表上最后一个结点

### 查找、插入和删除

在链表中插入或者删除一个数据，并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的，时间复杂度为 O(1)。

有利就有弊，链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点，事件复杂度为 O(n)。

## 循环链表

**一种特殊的单链表**。

它跟单链表唯一的区别就在尾结点，循环链表的尾结点指针指向链表的头结点。

循环链表的优点是从链尾到链头比较方便，特别适合处理环型结构的数据。如[约瑟夫问题](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)。

### 如何判断是循环链表

快慢指针！

## 双向链表

双向链表，支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。

![双向链表](@imgs/cbc8ab20276e2f9312030c313a9ef70b.jpg)

双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，存储同样多的数据，双向链表要比单链表占用更多的内存空间。

但双向链表可以支持双向遍历，这样也带来了双向链表操作的灵活性。那相比单链表，双向链表适合解决哪种问题呢？

双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。

但是单链表的插入、删除操作的时间复杂度已经是 O(1) 了，双向链表还能再怎么高效呢？

以删除操作为例，实际开发时，从链表中删除一个数据无外乎这两种情况：

1. 删除结点中“值等于某个给定值”的结点

尽管单纯的删除操作时间复杂度是 O(1)，但主要的耗时点是遍历查找，对应的时间复杂度为 O(n)。

2. 删除给定指针指向的结点

此时虽然已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以：

- 对于单链表为了找到前驱结点，我们还是要从头结点开始遍历链表，时间复杂度为 O(n)
- 对于双向链表，可以通过前驱指针找到前驱结点，时间复杂度为 O(1)

同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。

除此以外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

总的来说，双向链表要比单链表更加高效，所以在实际的软件开发中，尽管比较费内存，双向链表还是比单链表的应用更加广泛。如 Java 中的 `LinkedHashMap` 的实现中就用到了双向链表。

### 空间换时间

对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。

## 数组 or 链表

数组在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高（CPU 从内存读取数据的时会先把读取到的数据加载到 CPU 的缓存中，且每次从内存读取的是一个数据块，而数组的存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到 CPU 缓存）。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。

而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片。

所以，在我们实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表。

## 缓存淘汰算法（LRU）

缓存是我们比较熟悉的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？

这就需要缓存淘汰策略来决定。常见的策略有三种：

- 先进先出策略 FIFO（First In，First Out）
- 最少使用策略 LFU（Least Frequently Used）
- 最近最少使用策略 LRU（Least Recently Used）

这些策略和我们“断舍离”时，需要扔掉一些东西类似。

那么如何基于链表实现 LRU 缓存淘汰算法？

维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部
2. 此数据没有在缓存链表中：
  - 此时缓存未满，将此结点直接插入到链表的头部
  - 此时缓存已满，链表尾结点删除，将新的数据结点插入链表的头部

那么时间复杂度为O(n)，因为不管缓存有没有满，我们都需要遍历一遍链表。

## 编写链表代码的技巧

想要写好链表代码并不是容易的事儿，尤其是那些复杂的链表操作，比如链表反转、有序链表合并等，写的时候非常容易出错。下面是总结的写链表代码技巧：

### 理解指针与引用的含义

要想写对链表代码，首先就要理解好指针。有些语言没有指针，取而代之的是“引用”，比如 Java、Python。不管是“指针”还是“引用”，实际上，它们的意思都是一样的，都是存储所指对象的内存地址。

对于指针只需要记住下面这句话就可以了：**指针中存储的是内存地址，将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针。反过来说，指针中存储了这个变量的内存地址，那么通过指针就能找到这个变量**。

代码 `p->next = q` 表示 p 结点中的 next 指针存储了 q 结点的内存地址。更复杂的 `p->next = p->next->next` 表示 p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址。

### 警惕指针丢失和内存泄漏

写链表代码的时候，一定注意不要弄丢了指针。以插入结点为例：

![插入结点](@imgs/05a4a3b57502968930d517c934347c6e.jpg)

我们可能会写出这样的代码：

```c
p->next = x;  // 将p的next指针指向x结点；
x->next = p->next;  // 将x的结点的next指针指向b结点；
```

`p->next` 指针在完成第一步操作之后，已经不再指向结点 b 了，而是指向结点 x。第 2 行代码相当于将 x 赋值给 `x->next`，自己指向自己。因此，整个链表也就断成了两半，从结点 b 往后的所有结点都无法访问到了。

对于有些语言来说，比如 C 语言，内存管理是由程序员负责的，如果没有手动释放结点对应的内存空间，就会产生内存泄露。

所以，我们插入结点时，一定要注意操作的顺序，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。

所以，对于刚刚的插入代码，我们只需要把第 1 行和第 2 行代码的顺序颠倒一下就可以了。同理，删除链表结点时，也一定要记得手动释放内存空间，否则，也会出现内存泄漏的问题。当然，对于像 Java 这种虚拟机自动管理内存的编程语言来说，就不需要考虑这么多了。

### 利用哨兵简化实现难度

在结点 p 后面插入一个新的结点，只需要下面两行代码就可以搞定：

```c
new_node->next = p->next;
p->next = new_node;
```

但是，当我们要向一个空链表中插入第一个结点，刚刚的逻辑就不能用了。

```c
// head 表示链表的头结点
if (head == null) {
  head = new_node;
}
```

也就是说，head 结点的插入逻辑和其他结点的插入逻辑是不一样的。

同样的，删除一个结点的后继结点，只需要下面这一行代码就可以搞定：

```c
p->next = p->next->next
```

但是，如果要删除链表的最后一个结点，就需要特殊处理：

```c
if (head->next == null) {
  head = null
}
```

综上，链表的插入、删除操作，需要对第一个结点和最后一个结点的情况进行特殊处理。

但是这么做感觉很繁琐，而且容易因为考虑不全而出错。此时可以**通过哨兵解决边界问题**。

- 带头链表：引入哨兵结点，head 指针永远指向哨兵结点
- 不带头链表：没有哨兵结点

![哨兵结点](@imgs/7d22d9428bdbba96bfe388fe1e3368c7.jpg)

哨兵结点不存储数据，因为哨兵结点一直存在，所以插入第一个结点和插入其他节点的操作，就都一样；删除最后一个结点的操作和删除其他结点的操作，也都一样了。

### 重点留意边界条件处理

常用的检查链表代码是否正确的边界条件有：

- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

### 举例画图，辅助思考

对于稍微复杂的链表操作，需要举例法和画图法。把各种情况都举一个例子，画出插入前和插入后的链表变化，如图所示：

![画图](@imgs/4a701dd79b59427be654261805b349f8.jpg)

### 多写多练，没有捷径

下面是常见的链表操作：

- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第 n 个结点
- 求链表的中间结点
