# 双向链表

双向链表，支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。

![双向链表](@imgs/cbc8ab20276e2f9312030c313a9ef70b.jpg)

双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，存储同样多的数据，双向链表要比单链表占用更多的内存空间。

但双向链表可以支持双向遍历，这样也带来了双向链表操作的灵活性。那相比单链表，双向链表适合解决哪种问题呢？

双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。

但是单链表的插入、删除操作的时间复杂度已经是 O(1) 了，双向链表还能再怎么高效呢？

以删除操作为例，实际开发时，从链表中删除一个数据无外乎这两种情况：

1. 删除结点中“值等于某个给定值”的结点

尽管单纯的删除操作时间复杂度是 O(1)，但主要的耗时点是遍历查找，对应的时间复杂度为 O(n)。

2. 删除给定指针指向的结点

此时虽然已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以：

- 对于单链表为了找到前驱结点，我们还是要从头结点开始遍历链表，时间复杂度为 O(n)
- 对于双向链表，可以通过前驱指针找到前驱结点，时间复杂度为 O(1)

同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。

除此以外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

```ts
interface DoublyLinkedListNode<T> {
  data: T;
  prev: DoublyLinkedListNode<T>;
  next: DoublyLinkedListNode<T>;
}
```

总的来说，双向链表要比单链表更加高效，所以在实际的软件开发中，尽管比较费内存，双向链表还是比单链表的应用更加广泛。如 Java 中的 `LinkedHashMap` 的实现中就用到了双向链表。

## 空间换时间

**对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗**。
