# 动态规划

**动态规划适合用来求解最优问题**。它可以非常显著地降低时间复杂度，提高代码的执行效率。

## 0-1 背包问题

对于一组不同重量、不可分割的物品，需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？

可以通过回溯方法，穷举搜索所有可能的装法，然后找出满足条件的最大值。但是回溯算法的复杂度比较高，是指数级别的。

<!-- TODO -->

如图，假设背包的最大承载重量是 9，有 5 个不同的物品，每个物品的重量分别是 2，2，4，6，3。

如果把这个例子的回溯求解过程，用递归树画出来，就是下面这个样子：

![递归树](@imgs/42ca6cec4ad034fc3e5c0605fbacecea.jpg)

递归树中的每个节点表示一种状态，用（i, cw）来表示：

- i 表示将要决策第几个物品是否装入背包
- cw 表示当前背包中物品的总重量
- 比如，（2，2）表示将要决策第 2 个物品是否装入背包，在决策前，背包中物品的总重量是 2。

从递归树中可以发现，有些子问题的求解是重复的，比如图中 f(2, 2) 和 f(3, 4) 都被重复计算了两次，可以借助“备忘录”避免冗余计算。

<!-- TODO -->

这种解决方法和动态规划的执行效率基本上没有差别，看看动态规划是怎么做的：

- 把整个求解过程分为 n 个阶段
- 每个阶段会决策一个物品是否放到背包中
- 每个物品决策（放入或者不放入背包）完之后，背包中的物品的重量会有多种情况，也就是说，会达到多种不同的状态，对应到递归树中，就是有很多不同的节点
- 把每一层重复的状态（节点）合并，只记录不同的状态
- 然后基于上一层的状态集合，来推导下一层的状态集合

通过合并每一层重复的状态，这样就保证每一层不同状态的个数都不会超过 w 个（w 表示背包的承载重量），也就是例子中的 9。于是就成功避免了每层状态个数的指数级增长。
我们用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。第 0 个（下标从 0 开始编号）物品的重量是 2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 0 或者 2。我们用 states[0][0]=true 和 states[0][2]=true 来表示这两种状态。第 1 个物品的重量也是 2，基于之前的背包状态，在这个物品决策完之后，不同的状态有 3 个，背包中物品总重量分别是 0(0+0)，2(0+2 or 2+0)，4(2+2)。我们用 states[1][0]=true，states[1][2]=true，states[1][4]=true 来表示这三种状态。以此类推，直到考察完所有的物品后，整个 states 状态数组就都计算好了。我把整个计算的过程画了出来，你可以看看。图中 0 表示 false，1 表示 true。我们只需要在最后一层，找一个值为 true 的最接近 w（这里是 9）的值，就是背包中物品总重量的最大值。
