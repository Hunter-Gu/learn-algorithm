# 动态规划

**动态规划适合用来求解最优问题**。它可以非常显著地降低时间复杂度，提高代码的执行效率。

## 0-1 背包问题

对于一组不同重量、不可分割的物品，需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？

可以通过回溯方法，穷举搜索所有可能的装法，然后找出满足条件的最大值。但是回溯算法的复杂度比较高，是指数级别的。

<!-- TODO -->

如图，假设背包的最大承载重量是 9，有 5 个不同的物品，每个物品的重量分别是 2，2，4，6，3。

如果把这个例子的回溯求解过程，用递归树画出来，就是下面这个样子：

![递归树](@imgs/42ca6cec4ad034fc3e5c0605fbacecea.jpg)

递归树中的每个节点表示一种状态，用（i, cw）来表示：

- i 表示将要决策第几个物品是否装入背包
- cw 表示当前背包中物品的总重量
- 比如，（2，2）表示将要决策第 2 个物品是否装入背包，在决策前，背包中物品的总重量是 2。

从递归树中可以发现，有些子问题的求解是重复的，比如图中 f(2, 2) 和 f(3, 4) 都被重复计算了两次，可以借助“备忘录”避免冗余计算。

<!-- TODO -->

这种解决方法和动态规划的执行效率基本上没有差别，看看动态规划是怎么做的：

- 把整个求解过程分为 n 个阶段
- 每个阶段会决策一个物品是否放到背包中
- 每个物品决策（放入或者不放入背包）完之后，背包中的物品的重量会有多种情况，也就是说，会达到多种不同的状态，对应到递归树中，就是有很多不同的节点
