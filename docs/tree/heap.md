# 堆

堆：一种特殊的树，满足以下条件：

- 完全二叉树
- 每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值
  - 大于等于：大顶堆
  - 小于等于：小顶堆

## 如何实现一个堆

要实现一个堆，先要知道：

- 堆支持哪些操作
- 如何存储一个堆

之前讲过，完全二叉树比较适合用数组来存储，那么堆也一样。

> 堆的操作都以大顶堆为例!

### 堆化

堆化（heapify）：如果把新插入的元素放到堆的最后，不符合堆的特性，就需要进行调整，让其重新满足堆的特性。

有两种堆化方式：

- 从下往上：和父节点比较
- 从上往下：和左、右两个子节点比较

堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。以从下往上为例：

![从下往上](@imgs/e3744661e038e4ae570316bc862b2c0e.jpg)

### 插入

往堆中插入一个元素后，需要让它继续满足堆的两个特性。

```ts
class Heap<T> {

  private readonly root = 1;

  private arr!: T[];

  private count = 0;

  constructor(rootData: T, size: number) {
    this.arr = new Array(size + this.root).fill(null));
    this.arr[this.root] = rootData;
    this.count += 1;
  }

  insert(data: T) {
    // 堆满
    if (this.count >= arr.length - 1) return

    this.count += 1;
    this.arr[this.count] = data;

    let idx = this.count,
        parentIdx = Math.floor(this.count / 2)
    // 从下往上堆化
    while (parentIdx > 0 && this.arr[i] > this.arr[parentIdx]) {
      const tmp = this.arr[i]
      this.arr[i] = this.arr[parentIdx]
      this.arr[parentIdx] = tmp
      idx = parentIdx
      parentIdx = Math.floor(idx / 2)
    }
  }
}
```

### 删除堆顶元素

从堆的第二条定义可以发现，堆顶元素存储的是堆中数据的最大值或者最小值。

假设构造的是大顶堆，堆顶元素就是最大的元素：

- 当删除堆顶元素之后，就需要把第二大的元素放到堆顶，而第二大元素肯定会出现在左、右子节点中
- 接着再迭代地删除第二大节点
- 以此类推，直到叶子节点被删除

如图：

![删除堆顶元素](@imgs/5916121b08da6fc0636edf1fc24b5a81.jpg)

把数组中的最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止，这就是从上往下的堆化方法。

![从下往上堆叠](@imgs/110d6f442e718f86d2a1d16095513260.jpg)

```ts
class Heap<T> {

  private readonly root = 1;

  private arr!: T[];

  private count = 0;

  constructor(rootData: T, size: number) {
    this.arr = new Array(size + this.root).fill(null));
    this.arr[this.root] = rootData;
    this.count += 1;
  }

  removeMax() {
    if (this.count === 0) return

    this.count -= 1

    heapify(this.arr, this.root)
  }

  // 从上向下堆化
  heapify(arr: T[], idx: number, size: number) {
    while (true) {
      const leftIdx = idx * 2,
            rightIdx = idx * 2 + 1
      let maxIdx = idx

      if (leftIdx <= size && arr[maxIdx] < arr[leftIdx]) maxIdx = leftIdx
      if (rightIdx <= size && arr[maxIdx] < arr[rightIdx]) maxIdx = rightIdx
      if (maxIdx === idx) break

      const tmp = arr[idx]
      arr[idx] = arr[maxIdx]
      arr[maxIdx] = tmp
      idx = maxIdx
    }
  }
}
```

堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 O(logn)。

插入数据和删除堆顶元素的主要逻辑就是堆化，所以往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。

## 堆排序

借助于堆实现的排序算法，就叫作堆排序。

堆排序的时间复杂度非常稳定，是 O(nlogn)，并且它还是原地排序算法。如此优秀，它是怎么做到的呢？

把堆排序的过程大致分解成两个大的步骤：

- 建堆
- 排序

### 建堆

首先，将数组原地（不借助另一个数组，就在原数组上操作）建成一个堆。建堆的过程，有两种思路：

#### 从下往上堆化

思路一：在堆中插入一个元素。

尽管数组中包含 n 个数据，但是可以假设，起初堆中只包含一个数据，就是下标为 1 的数据。

然后，调用前面讲的插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样就将包含 n 个数据的数组，组织成了堆。

这种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。

```ts
// 从前向后处理
function buildHeap<T>(arr: T[], size: number) {
  for (let i = 2; i <= size; i++) {
    heapify(arr, i)
  }
}

// 从下往上堆化
function heapify<T>(arr: T[], idx: number) {
  let parentIdx = Math.floor(idx / 2)

  while (parentIdx > 0 && arr[idx] > arr[parentIdx]) {
    const tmp = arr[idx]
    arr[idx] = arr[parentIdx]
    arr[parentIdx] = tmp
    idx = parentIdx
    parentIdx = Math.floor(idx / 2)
  }
}
```

#### 从上往下堆化

思路二：从后往前处理数组，并且每个数据都是从上往下堆化。

如图，叶子节点往下堆化只能自己跟自己比较，所以直接从下标 n / 2​ 到 1（第一个非叶子节点）进行堆化：

![步骤 1](@imgs/50c1e6bc6fe68378d0a66bdccfff441e.jpg)

![步骤 2](@imgs/aabb8d15b1b92d5e040895589c60419d.jpg)

```ts
// 从后向前处理
function buildHeap<T>(arr: T[], size: number) {
  // 从最后一个非叶子节点开始
  for (let i = Math.floor(size / 2); i >= 1; i--) {
    heapify(arr, i, size)
  }
}

// 从上往下堆化
function heapify<T>(arr: T[], idx: number, size: number) {
  while (true) {
    const leftIdx = idx * 2,
          rightIdx = idx * 2 + 1
    let maxIdx = idx

    if (leftIdx <= size && arr[maxIdx] < arr[leftIdx]) maxIdx = leftIdx
    if (rightIdx <= size && arr[maxIdx] < arr[rightIdx]) maxIdx = rightIdx
    if (maxIdx === idx) break

    const tmp = arr[idx]
    arr[idx] = arr[maxIdx]
    arr[maxIdx] = tmp
    idx = maxIdx
  }
}
```

#### 建堆的时间复杂度 - O(n)

叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度 k 成正比。

每一层的节点个数和对应的高度如图：

![每一层的节点个数和对应的高度](@imgs/899b9f1b40302c9bd5a7f77f042542d5.jpg)

将每个非叶子节点的高度求和，得出的就是建堆的时间复杂度。

![时间复杂度公式](@imgs/f712f8a7baade44c39edde839cefcc09.jpg)

![两边乘 2](@imgs/629328315decd96e349d8cb3940636df.jpg)

把 h = log​n 代入公式 S，就能得到 S = O(n)，所以，建堆的时间复杂度就是 O(n)。

### 排序

建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。排序的过程有点类似[删除堆顶元素](/tree/heap.html#删除堆顶元素)的操作。

- 数组中的第一个元素就是堆顶，也就是最大的元素，把它跟最后一个元素交换
- 然后通过堆化的方法，将剩下的 n − 1 个元素重新构建成堆
- 堆化完成之后，再取堆顶的元素，放到下标是 n − 1 的位置
- 一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了

![堆的排序](@imgs/23958f889ca48dbb8373f521708408d1.jpg)

```ts
function sort<T>(arr: T[], size: number) {
  const rootIdx = 1
  // 先建堆
  buildHeap(arr, size)
  // 再排序
  for (let i = size - 1; i > rootIdx; i--) {
    const tmp = arr[rootIdx]
    arr[rootIdx] = tmp[i]
    arr[i] = tmp
    heapify(arr, 1, i)
  }
}

function heapify<T>(arr: T[], idx: number, size: number) {
  while (true) {
    const leftIdx = idx * 2,
          rightIdx = idx * 2 + 1
    let maxIdx = idx

    if (leftIdx <= size && arr[maxIdx] < arr[leftIdx]) maxIdx = leftIdx
    if (rigthIdx <= size && arr[maxIdx] < arr[rightIdx]) maxIdx = rightIdx
    if (maxIdx === idx) break

    const tmp = arr[idx]
    arr[idx] = arr[maxIdx]
    arr[maxIdx] = tmp
    idx = maxIdx
  }
}
```

#### 复杂度 & 稳定性

整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。

堆排序包括以下两个操作：

- 建堆：时间复杂度是 O(n)
- 排序：时间复杂度是 O(nlogn)

所以，堆排序整体的时间复杂度是 O(nlogn)。

**堆排序不是稳定的排序算法**。因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。

## 应用

### 优先级队列

优先级队列：按照优先级出队，优先级最高的，最先出队。

#### 如何实现

用堆来实现优先级队列是最直接、最高效的，因为堆和优先级队列非常相似，一个堆就可以看作一个优先级队列。

很多时候，它们只是概念上的区分而已：

- 往优先级队列中插入一个元素，就相当于往堆中插入一个元素
- 从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素

优先级队列的应用场景非常多，很多数据结构和算法都要依赖它，如：

- 赫夫曼编码
- 图的最短路径
- 最小生成树算法
- ...

#### 合并有序小文件

有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串，现在希望将这些 100 个小文件合并成一个有序的大文件，怎么做？

使用优先级队列。整体思路有点像归并排序中的合并函数：

- 从这 100 个文件中，各取第一个字符串，放入数组中，然后比较大小
- 把最小的那个字符串放入合并后的大文件中，并从数组中删除
- 再从这个小文件取下一个字符串，放到数组中，然后比较大小，重复执行上述过程
- ...
- 依次类推，直到所有的文件中的数据都放入到大文件为止

用数组来存储从小文件中取出来的字符串，每次从数组中取最小字符串，都需要循环遍历整个数组，显然不是很高效。

使用优先级队列（也可以说是堆）：

- 将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串
- 将这个字符串放入到大文件中，并将其从堆中删除
- 再从小文件中取出下一个字符串，放入到堆中，循环这个过程
- ...
- 可以将 100 个小文件中的数据依次放入到大文件中

删除堆顶数据和往堆中插入数据的时间复杂度都是 O(logn)，n 表示堆中的数据个数，这里就是 100。

#### 高性能定时器

假设有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。

定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间，如果到达了，就拿出来执行。

![定时任务](@imgs/b04656d27fd0ba112a38a28c892069e7.jpg)

但是这样每过 1 秒就扫描一遍任务列表的做法比较低效。

主要原因有两点：

- 任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的
- 每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时

可以用优先级队列来解决这些问题。

按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务。

这样，定时器就不需要每隔 1 秒就扫描一遍任务列表了。它拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T。

这个时间间隔 T 就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行。这样，定时器就可以设定在 T 秒之后，再来执行任务。从当前时间点到（T-1）秒这段时间里，定时器都不需要做任何事情。

当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间。

这样，定时器既不用间隔 1 秒就轮询一次，也不用遍历整个任务列表，性能也就提高了。

### 利用堆求 Top K

堆的另外一个非常重要的应用场景是“求 Top K 问题”。

这种求 Top K 的问题可以抽象成两类：

- 针对静态数据集合：数据集合事先确定，不会再变
- 针对动态数据集合：数据集合事先并不确定，有数据动态地加入到集合中

#### 静态数据集合

针对静态数据，如何在一个包含 n 个数据的数组中，查找前 K 大数据呢？

- 先以数组的前 K 项数据建立**小顶堆**
- 顺序遍历数组，从数组中取出数据与堆顶元素比较
  - 如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中，并堆化
  - 如果比堆顶元素小，则不做处理，继续遍历数组
- 等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了

遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK) 的时间复杂度，所以最坏情况下，n 个元素都入堆一次，时间复杂度就是 O(nlogK)。

```ts
function heapify<T>(arr: T[], idx: number) {
  let parentIdx = Math.floor(idx / 2)
  while (parentIdx > 0 && arr[idx] < arr[parentIdx]) {
    const tmp = arr[idx]
    arr[idx] = arr[parentIdx]
    arr[parentIdx] = tmp
    idx = parentIdx
    parentIdx = Math.floor(idx / 2)
  }
}

function findTopK<T>(arr: T[], k: number) {
  const rootIdx = 1

  const minHeap = new Array(k + 1).fill(null)
  for (let i = rootIdx; i <= k; i++) {
    minHeap[i] = arr[i - 1]
  }

  // 建小顶堆
  for (let i = rootIdx; i <= k; i++) {
    heapify(minHeap, i)
  }

  // 比较和插入
  for (let i = k + 1; i < arr.length; i++) {
    if (arr[i] > minHeap[rootIdx]) {
      minHeap[rootIdx] = arr[i]
      heapify(minHeap, k)
    }
  }

  return minHeap
}
```

#### 动态数据集合

针对动态数据求得 Top K 就是实时 Top K，一个数据集合中有两个操作：

- 添加数据
- 询问当前的前 K 大数据

如果每次询问前 K 大数据，都基于当前的数据重新计算的话，那时间复杂度就是 O(n * logK)，n 表示当前的数据的大小。

可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，就拿它与堆顶的元素对比：

- 如果比堆顶元素大，就把堆顶元素删除，并且将这个元素插入到堆中
- 如果比堆顶元素小，则不做处理

这样，无论任何时候需要查询当前的前 K 大数据，都可以立刻返回给他。

### 利用堆求中位数

如何利用堆求动态数据集合中的中位数？

- 中位数：将数据从小到大排列，处于中间位置，就叫中位数，这个数据会大于等于前面 50% 的数据
- 数据的个数是奇数：把数据从小到大排列，那第 n / 2 + 1 个数据就是中位数（假设数据是从 0 开始编号的）
- 数据的个数是偶数：处于中间位置的数据有两个，第 n / 2 个和第 n / 2 ​+ 1 个数据。此时可以随意取一个作为中位数，比如取第 n / 2​ 个数据

#### 静态数据

对于一组静态数据，中位数是固定的，可以先排序，第 n / 2​ 个数据就是中位数。每次询问中位数的时候，直接返回这个固定的值就好了。所以，尽管排序的代价比较大，但是边际成本会很小。

#### 动态数据

如果面对的是动态数据集合，中位数在不停地变动，如果再用先排序的方法，每次询问中位数的时候，都要先进行排序，那效率就不高了。借助堆这种数据结构，不用排序就可以非常高效地实现求中位数操作。

维护两个堆：

- 大顶堆：存储前半部分数据
- 小顶堆：存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据

也就是说，如果有 n 个数据：

- 从小到大排序，大顶堆中的堆顶元素就是要找的中位数
- 大顶堆：存储前 n / 2（或 n / 2 + 1） 个数据
- 小顶堆：存储后 n / 2​ 个数据

以 1, 2, 3, 4, 5, 6, 7 为例，如图为构建的大顶堆和小顶堆：

![大顶堆和小顶堆](@imgs/08c29d3e014a4baf5f8148c2271e6099.jpg)

数据是动态变化的，当新添加一个数据的时候，如何调整两个堆，让大顶堆中的堆顶元素继续是中位数呢？

- 新加入的数据小于等于大顶堆的堆顶元素：将这个新数据插入到大顶堆
- 否则将这个新数据插入到小顶堆

这个时候就有可能出现，两个堆中的数据个数不符合前面约定的情况：

- n 是偶数：两个堆中的数据个数都是 n / 2​
- n 是奇数：大顶堆有 n / 2 + 1 个数据，小顶堆有 n / 2​ 个数据

这个时候，可以从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定。

![将小顶堆的堆顶取到大顶堆的堆顶](@imgs/aee4dcaf9d34111870a1d66a6e109fb1.jpg)

插入数据因为需要涉及堆化，所以时间复杂度变成了 O(logn)，但是求中位数只需要返回大顶堆的堆顶元素就可以了，所以时间复杂度就是 O(1)。

<!-- TODO -->
```ts

```

利用两个堆不仅可以快速求出中位数，还可以快速求其他百分位的数据，原理是类似的。

#### 求 99% 响应时间

比如利用两个堆如何来实现“快速求接口的 99% 响应时间？”

“99% 响应时间”：类比中位数，大于前面 99% 数据的那个数据。比如有 100 个数据，分别是 1，2，3，...，100，那 99 百分位数就是 99，因为小于等于 99 的数占总个数的 99%。

![中位数 & 99% 响应时间](@imgs/bbb043d369eeef1bb7feadd28c6ea32d.jpg)

如果有 100 个接口访问请求，每个接口请求的响应时间都不同，比如 55 毫秒、100 毫秒、23 毫秒等，我们把这 100 个接口的响应时间按照从小到大排列，排在第 99 的那个数据就是 99% 响应时间，也叫 99 百分位响应时间。

假设当前总数据的个数是 n，维护两个堆：

- 大顶堆：保存 n * 99% 个数据，堆顶的数据就是要找的第 99% 响应时间
- 小顶堆：保存 n * 1% 个数据

实现方式和求中位数的方式几乎一模一样。

## 思考

### 实际开发中，为什么快速排序要比堆排序性能好？

主要有两方面的原因。

第一点，堆排序数据访问的方式没有快速排序友好。

对于快速排序来说，数据是顺序访问的；而对于堆排序来说，数据是跳着访问的；这样对 CPU 缓存不友好。

第二点，对于同样的数据，在排序过程中，堆排序的数据交换次数要多于快速排序。

对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的：

- 比较
- 交换

快速排序数据交换的次数不会比逆序度多。但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。

![](@imgs/6e81fdde42ec3fd288d32eb866867fbd.jpg)

### 大文件查找 Top K

有一个包含 10 亿个搜索关键词的日志文件，如何快速获取到 Top 10 最热门的搜索关键词呢？

处理这个问题，有很多高级的解决方法，比如使用 MapReduce 等；但是如果将处理的场景限定为单机，可以使用的内存为 1GB。那这个问题该如何解决呢？

因为用户搜索的关键词，有很多可能都是重复的，所以首先要统计每个搜索关键词出现的频率。通过散列表、平衡二叉查找树或者其他一些支持快速查找、插入的数据结构，来记录关键词及其出现的次数。

假设选用散列表。顺序扫描这 10 亿个搜索关键词，当扫描到某个关键词时，去散列表中查询：

- 如果存在，就将对应的次数加一
- 如果不存在，就将它插入到散列表，并记录次数为 1
- 以此类推
- ...

遍历完这 10 亿个搜索关键词之后，散列表中就存储了不重复的搜索关键词以及出现的次数。

根据前面讲的用堆求 Top K 的方法，就可以求得 Top 10 搜索关键词了。

但是上面的解决思路其实存在漏洞。

假设 10 亿条搜索关键词中不重复的有 1 亿条，如果每个搜索关键词的平均长度是 50 个字节，那存储 1 亿个关键词起码需要 5GB 的内存空间，而散列表因为要避免频繁冲突，不会选择太大的装载因子，所以消耗的内存空间就更多了。

而机器只有 1GB 的可用内存空间，所以无法一次性将所有的搜索关键词加入到内存中。这个时候该怎么办呢？

相同数据经过哈希算法得到的哈希值是一样的，根据哈希算法的这个特点，可以先将 10 亿条搜索关键词先通过哈希算法分片到 10 个文件中。具体步骤如下：

- 创建 10 个空文件 00，01，02，...，09
- 遍历这 10 亿个关键词，并且通过某个哈希算法对其求哈希值，然后哈希值同 10 取模
- 得到的结果就是这个搜索关键词应该被分到的文件编号

对这 10 亿个关键词分片之后，每个文件都只有 1 亿的关键词，去除掉重复的，可能就只有 1000 万个，每个关键词平均 50 个字节，所以总的大小就是 500MB，1GB 的内存完全可以放得下。

接下来，针对每个包含 1 亿条搜索关键词的文件，利用散列表和堆，分别求出 Top 10，然后把这个 10 个 Top 10 放在一块，然后取这 100 个关键词中，出现次数最多的 10 个关键词，这就是这 10 亿数据中的 Top 10 最频繁的搜索关键词了。

### 题目

有一个访问量非常大的新闻网站，我们希望将点击量排名 Top 10 的新闻摘要，滚动显示在网站首页 banner 上，并且每隔 1 小时更新一次。如果你是负责开发这个功能的工程师，你会如何来实现呢？
