# 堆

堆：一种特殊的树，满足以下条件：

- 完全二叉树
- 每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值
  - 大于等于：大顶堆
  - 小于等于：小顶堆

## 如何实现一个堆

要实现一个堆，先要知道：

- 堆支持哪些操作
- 如何存储一个堆

之前讲过，完全二叉树比较适合用数组来存储，那么堆也一样。

:::tip
堆的操作都以大顶堆为例
:::

### 插入

往堆中插入一个元素后，需要让它继续满足堆的两个特性。

堆化（heapify）：如果把新插入的元素放到堆的最后，不符合堆的特性，就需要进行调整，让其重新满足堆的特性。

有两种堆化方式：

- 从下往上
- 从上往下

堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。以从下往上为例：

![从下往上](@imgs/e3744661e038e4ae570316bc862b2c0e.jpg)

<!-- TODO 代码 -->

### 删除堆顶元素

从堆的第二条定义可以发现，堆顶元素存储的是堆中数据的最大值或者最小值。

假设构造的是大顶堆，堆顶元素就是最大的元素。当删除堆顶元素之后，就需要把第二大的元素放到堆顶，而第二大元素肯定会出现在左、右子节点中。然后再迭代地删除第二大节点，以此类推，直到叶子节点被删除。如图：

![删除堆顶元素](@imgs/5916121b08da6fc0636edf1fc24b5a81.jpg)

把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止，这就是从上往下的堆化方法。

![从下往上堆叠](@imgs/110d6f442e718f86d2a1d16095513260.jpg)

<!-- TODO 代码 -->

一个包含 n 个节点的完全二叉树，树的高度不会超过 log​n。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 O(logn)。

插入数据和删除堆顶元素的主要逻辑就是堆化，所以往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。

## 堆排序

借助于堆实现的排序算法，就叫作堆排序。

堆排序的时间复杂度非常稳定，是 O(nlogn)，并且它还是原地排序算法。如此优秀，它是怎么做到的呢？

把堆排序的过程大致分解成两个大的步骤：

- 建堆
- 排序

### 建堆

首先，将数组原地（不借助另一个数组，就在原数组上操作）建成一个堆。建堆的过程，有两种思路：

#### 从下往上堆化

思路一：在堆中插入一个元素。

尽管数组中包含 n 个数据，但是可以假设，起初堆中只包含一个数据，就是下标为 1 的数据。

然后，调用前面讲的插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样就将包含 n 个数据的数组，组织成了堆。

这种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。

#### 从上往下堆化

思路二：从后往前处理数组，并且每个数据都是从上往下堆化。

如图，是第二种实现思路的建堆分解步骤图。因为叶子节点往下堆化只能自己跟自己比较，所以直接从第一个非叶子节点开始，依次堆化就行了：

![](@imgs/50c1e6bc6fe68378d0a66bdccfff441e.jpg)

![](@imgs/aabb8d15b1b92d5e040895589c60419d.jpg)

<!-- TODO 代码 -->

对下标从 n / 2​ 开始到 1 的数据进行堆化，下标是 n / 2 + 1 到 n 的节点是叶子节点，我们不需要堆化，因为对于完全二叉树来说，下标从 n / 2 + 1 到 n 的节点都是叶子节点。

#### 时间复杂度

每个节点堆化的时间复杂度是 O(logn)，那 n / 2 + 1 个节点堆化的总时间复杂度就是 O(nlogn)，但是这个值还不够精确。

堆排序的建堆过程的时间复杂度是 O(n)。为什么？

因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度 k 成正比。

每一层的节点个数和对应的高度如图：

![](@imgs/899b9f1b40302c9bd5a7f77f042542d5.jpg)

只需将每个非叶子节点的高度求和，得出的就是建堆的时间复杂度。

![](@imgs/f712f8a7baade44c39edde839cefcc09.jpg)

![](@imgs/629328315decd96e349d8cb3940636df.jpg)

因为 h = log​n，代入公式 S，就能得到 S = O(n)，所以，建堆的时间复杂度就是 O(n)。

### 排序
