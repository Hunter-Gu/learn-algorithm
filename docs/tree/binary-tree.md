# 二叉树

二叉树，每个节点**最多**有两个子节点，左子节点和右子节点。

![二叉树](@imgs/09c2972d56eb0cf67e727deda0e9412b.jpg)

- 满二叉树：除了叶子结点，每个节点都有左、右两个子节点。如图中的 (2)
- 完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作完全二叉树。如图中的 (3) TODO 感觉不明白

## 如何表示/存储一颗二叉树

### 基于指针/引用的二叉链式存储法

![链式存储](@imgs/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg)

大部分二叉树都通过链式存储实现，每个节点有三个字段：

- 数据
- 左子节点的指针
- 右子节点的指针

### 基于数组的顺序存储法

![完全二叉树顺序存储](@imgs/14eaa820cb89a17a7303e8847a412330.jpg)

以完全二叉树为例，将根节点存储在数组下标为 1 的位置：

- 左子节点存储在下标 2 * i 的位置
- 右子节点存储在下标 2 * i + 1 的位置
- 而 i / 2 位置存储的就是父节点

通过该方式，知道了根节点的位置，就可以遍历整棵树。

对于非完全二叉树，会浪费更多一点的存储空间：

![非完全二叉树顺序存储](@imgs/08bd43991561ceeb76679fbb77071223.jpg)

总结：用数组存储一颗完全二叉树，是最节省内存的方式。对于数组，不需要存储额外的左右子节点的指针。

## 遍历二叉树

- 前序遍历：先打印这个节点，然后再打印它的左子树，最后打印它的右子树
- 中序遍历：先打印它的左子树，然后再打印它本身，最后打印它的右子树
- 后序遍历：先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身

![遍历二叉树](@imgs/ab103822e75b5b15c615b68560cb2416.jpg)

二叉树的前、中、后序遍历就是一个递归的过程，递推公式如下：

```
preOrder(root) = print root + preOrder(root.left) + preOrder(root.right)

inOrder(root) = inOrder(root.left) + print root + inOrder(root.right)

postOrder(root) = postOrder(root.left) + postOrder(root.right) + print root
```

### 时间复杂度

从之前的图中，可以看出来，每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说二叉树遍历的时间复杂度是 O(n)。

## 思考

### 给定一组数据，比如 1，3，5，6，9，10。你来算算，可以构建出多少种不同的二叉树？

卡特兰数，是C[n,2n] / (n+1)种形状，c是组合数，节点的不同又是一个全排列，一共就是n!*C[n,2n] / (n+1)个二叉树。可以通过数学归纳法推导得出。

### 二叉树的层序遍历

层次遍历需要借助队列这样一个辅助数据结构。（其实也可以不用，这样就要自己手动去处理节点的关系，代码不太好理解，好处就是空间复杂度是o(1)。不过用队列比较好理解，缺点就是空间复杂度是o(n)）。根节点先入队列，然后队列不空，取出对头元素，如果左孩子存在就入列队，否则什么也不做，右孩子同理。直到队列为空，则表示树层次遍历结束。树的层次遍历，其实也是一个广度优先的遍历算法。
