# 红黑树（R-B Tree）

二叉查找树支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，理想情况下，时间复杂度是 O(logn)。

但是在频繁的动态更新过程中，可能会出现树的高度远大于 logn 的情况，从而导致各个操作的效率下降。极端情况下，二叉树会退化为链表，时间复杂度会退化到 O(n)。

要解决这个复杂度退化的问题，需要设计一种平衡二叉查找树。

## 平衡二叉查找树

平衡二叉查找树的目的是：**解决普通二叉查找树**在频繁的插入、删除等动态更新的情况下，出现**时间复杂度退化的问题**。

平衡二叉树的严格定义：**二叉树中任意一个节点的左、右子树的高度相差不能大于 1**。从定义来看，完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。

![平衡二叉树 & 非平衡二叉树](@imgs/dd9f5a4525f5029a8339c89ad1c8159b.jpg)

平衡二叉查找树既满足平衡二叉树的定义，又满足二叉查找树的特点。

### 自平衡二叉查找（AVL ）树

最先被发明的平衡二叉查找树是 [AVL 树](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)，它严格符合平衡二叉树的定义（任何节点的左、右子树高度差不大于 1）。

## 红黑树

很多平衡二叉查找树其实并没有严格符合平衡二叉树的定义。比如红黑树，它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。

学习数据结构和算法是为了应用到实际的开发中的，所以没必要死抠定义。对于平衡二叉查找树这个概念，要从这个数据结构的由来，去理解“平衡”的意思。

“平衡”的意思：让整棵树左右看起来比较“对称”、比较“平衡”，**不要出现左子树很高、右子树很矮的情况**。这样就能**让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些**。

所以，设计新的平衡二叉查找树时，只要树的高度不比 logn 大很多（比如树的高度仍然是对数量级的），尽管不符合严格的平衡二叉查找树的定义，但仍然可以认为是一个合格的平衡二叉查找树。

### 是什么

红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：

- 根节点是黑色的
- 每个叶子节点都是黑色的空节点（NIL），即叶子节点不存储数据（为了简化红黑树的代码实现）
- 任何红色节点的子节点，不能是红色
- 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点

### “近似平衡”

红黑树是“近似平衡”的。

前面讲过，平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。所以，“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重。

下面是两个红黑树图例，为了简单将黑色的、空的叶子节点都省略掉了：

![红黑树](@imgs/903ee0dcb62bce2f5b47819541f9069a.jpg)

一棵极其平衡的二叉树（满二叉树或完全二叉树）的高度大约是 logn，所以如果要证明红黑树是近似平衡的，我们只需要分析，红黑树的高度是否比较稳定地趋近 logn 就好了。

**将红色节点从红黑树中去除，计算单纯包含黑色节点的红黑树的高度**。

删除红色节点后，有些节点就没有父节点了，它们直接拿祖父节点作为父节点。那么二叉树就变成了四叉树。

![去掉红色节点](@imgs/903ee0dcb62bce2f5b47819541f9069a.jpg)

从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小。

完全二叉树的高度近似 logn，这里的四叉“黑树”的高度要低于完全二叉树，所以去掉红色节点的“黑树”的高度也不会超过 logn。

**把红色节点加回去，树的高度是多少？**

在红黑树中，红色节点不能相邻，也就是说，有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开。

红黑树中包含最多黑色节点的路径不会超过 logn，所以加入红色节点之后，最长路径不会超过 2logn。也就是说，红黑树的高度近似 2logn。

所以，红黑树的高度只比高度平衡的 AVL 树的高度（logn）仅仅大了一倍，在性能上，下降得并不多。

## 怎么做 - 如何实现红黑树

> 红黑树的实现是比较难的，没必要死磕。

### 基本思想

一句话：**遇到什么样的节点排布，就对应怎么去调整**，也就是说是有固定套路的。

回顾一下一棵[合格红黑树满足的要求](/tree/red-black-tree.html#是什么)，在插入、删除操作的过程中，第 3, 4 两点要求可能被破坏，通过[平衡调整](/tree/red-black-tree.html#平衡调整)把被破坏的 3, 4 两点恢复。

### 两个操作

![左旋 & 右旋](@imgs/0e37e597737012593a93105ebbf4591e.jpg)

[平衡调整](/tree/red-black-tree.html#平衡调整)中，会一直用到这两个操作：

- 左旋
- 右旋

## 平衡调整

红黑树的平衡调整过程是一个迭代的过程。

正在处理的节点叫作**关注节点**。关注节点会随着不停地迭代处理，而不断发生变化。

### 插入操作

红黑树规定，**插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上**。

所以，关于插入操作的平衡调整，有这样两种特殊情况：

- 插入节点的父节点是黑色：什么都不用做，它仍然满足红黑树的定义
- 插入的节点是根节点：直接改变它的颜色，把它变成黑色

除此之外的其他情况，都会违背红黑树的定义，就需要进行调整，调整的过程包含两种基础的操作：

- 左右旋转
- 改变颜色

新节点插入后，如果红黑树的平衡被打破，一般会有下面三种情况。根据每种情况的特点，不停地调整，就可以让红黑树继续符合定义（保持平衡）。

CASE 1：**关注节点是 a，它的叔叔节点 d 是红色**，执行以下操作：

- 将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色
- 将关注节点 a 的祖父节点 c 的颜色设置成红色
- 关注节点变成 a 的祖父节点 c
- 跳到 CASE 2 或者 CASE 3

![叔叔节点是红色](@imgs/603cf91f54b5db21bd02c6c5678ecf40.jpg)

CASE 2：**关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点**，执行以下操作：

- 关注节点变成节点 a 的父节点 b
- 围绕新的关注节点b 左旋
- 跳到 CASE 3

![叔叔节点是黑色，关注节点是其父节点的右子节点](@imgs/4480a314f9d83c343b8adbb28b6782ad.jpg)

CASE 3：**关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点**，执行以下操作：

- 围绕关注节点 a 的祖父节点 c 右旋
- 将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换
- 调整结束

![叔叔节点是黑色，关注节点是其父节点的左子节点](@imgs/04650d9470b1e67899f5b8b7b8e33212.jpg)

### 删除操作

删除操作的平衡调整分两步：

- 针对删除节点初步调整，保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求（每个节点从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点）
- 针对关注节点进行二次调整，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点

#### 针对删除节点初步调整

:::tip
注意：红黑树的定义中“只包含红色节点和黑色节点”，经过初步调整之后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色，“红 - 黑”或者“黑 - 黑”
- 如果一个节点被标记为了“黑 - 黑”，那在计算黑色节点个数的时候，要算成两个黑色节点
- 在下面的讲解中，如果一个节点既可以是红色，也可以是黑色，在画图的时候，用一半红色一半黑色来表示
- 如果一个节点是“红 - 黑”或者“黑 - 黑”，用左上角的一个小黑点来表示额外的黑色
:::

CASE 1：**删除的节点是 a，它只有一个子节点 b**，执行以下操作：

- 删除节点 a，并且把节点 b 替换到节点 a 的位置
- 节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。这种情况下，我们把节点 b 改为黑色
- 调整结束，不需要进行二次调整

![](@imgs/a6c4c347b7cbdf57662bab399ed36cc3.jpg)

CASE 2：**要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c**，执行以下操作：

- 如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。我们把节点 a 删除，并且将节点 c 替换到节点 a 的位置
- 然后把节点 c 的颜色设置为跟节点 a 相同的颜色
- 如果节点 c 是黑色，为了不违反红黑树的最后一条定义，给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了“红 - 黑”或者“黑 - 黑”
- 这个时候，关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做

![](@imgs/48e3bd2cdd66cb635f8a4df8fb8fd64e.jpg)



CASE 1：**关注节点为 a，它的兄弟节点 c 是红色的**，执行以下操作：

- 围绕关注节点 a 的父节点 b 左旋
- 关注节点 a 的父节点 b 和祖父节点 c 交换颜色
- 关注节点不变
- 继续从四种情况中选择适合的规则来调整

![兄弟节点为红色](@imgs/ac76d78c064a2486e2a5b4c4903acb91.jpg)

CASE 2：**关注节点为 a，它的兄弟节点 c 是黑色的，且节点 c 的左、右子节点 d、e 都是黑色的**，执行以下操作：

- 将关注节点 a 的兄弟节点 c 的颜色变成红色
- 从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色
- 给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红 - 黑”或者“黑 - 黑”
- 关注节点从 a 变成其父节点 b
- 继续从四种情况中选择符合的规则来调整

![兄弟节点为黑色，且兄弟节点的左、右子节点都是黑色](@imgs/eca118d673c607eb2b103f3476fb24ec.jpg)

CASE 3：**关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色**，执行以下操作：

- 围绕关注节点 a 的兄弟节点 c 右旋
- 节点 c 和节点 d 交换颜色
- 关注节点不变
- 跳转到 CASE 4，继续调整

CASE 4：**关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的**，执行以下操作：

- 围绕关注节点 a 的父节点 b 左旋
- 将关注节点 a 的兄弟节点 c 的颜色，跟关注节点 a 的父节点 b 设置成相同的颜色
- 将关注节点 a 的父节点 b 的颜色设置为黑色
- 从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色
- 将关注节点 a 的叔叔节点 e 设置为黑色
- 调整结束

## 思考

### 为什么工程中喜欢用红黑树？

前面提到 Treap、Splay Tree，绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说，它们并不适用。

AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。

红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。

红黑树是一种性能非常稳定的二叉查找树，所以在工程中，但凡是用到动态插入、删除、查找数据的场景，都可以用到它。不过，它实现起来比较复杂，如果自己写代码实现，难度会有些高，这个时候，我们其实更倾向用跳表来替代它。
