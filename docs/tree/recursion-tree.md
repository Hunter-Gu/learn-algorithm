# 递归树

递归树：用于分析递归算法的时间复杂度。在[排序](/sort)部分，我们利用递推公式也可以求解时间复杂度，但是有些情况递推公式并不合适，比如分析[快排](/sort/quick.html#平均情况时间复杂度)的平均情况时间复杂度。

## 递归树与时间复杂度分析

递归的思想是：将大问题分解为小问题求解。

把这一层层的分解过程画成图，它就是一棵树 -- 递归树。如图所示是斐波那契数列的递归树：

![斐波那契数列的递归树](@imgs/1d9648b7f43e430473d76d24803159a3.jpg)

那么如何用递归树来分析时间复杂度呢？

以归并排序为例，来看一下如何用递归树来分析递归代码的时间复杂度。

- 首先把归并排序画成递归树：

![归并排序的递归树](@imgs/c66bfc3d02d3b7b8f64c208bf4c948d0.jpg)

每次分解都是一分为二，代价很低，把时间上的消耗记为常量 1。

- 对于耗时的归并操作，从图中可以看出，每一层消耗的时间总和是一样的，记为 n。

现在，只需要知道树的高度 h，就可以得到总的时间复杂度 O(n * h)。

从归并排序的递归树，我们可以看出来这是一棵满二叉树，而满二叉树的高度大约是 logn，所以归并排序的时间复杂度就是 O(nlogn)。虽然这里的时间复杂度都是估算的，对树的高度的计算也没有那么精确，但是这并不影响复杂度的计算结果。

## 实战

### 快速排序时间复杂度

用递推公式来求解快速排序的平均时间复杂度非常复杂：

- 在最好情况下，每次分区都能一分为二，这个时候用递推公式 T(n) = 2T(n / 2​) + n，很容易就能推导出时间复杂度是 O(nlogn)
- 假设平均情况下，每次分区之后，两个分区的大小比例为 1 : k。当 k = 9 时，如果用递推公式的方法来求解时间复杂度的话，递推公式就写成 T(n) = T(n / 10​ ) +T(9n/ 10​) + n

通过公式推导时间复杂度的过程非常复杂。那么用递归树来分析快速排序的平均情况时间复杂度，是不是比较简单呢？

![快速排序的递归树](@imgs/44972a3531dae0b7a0ccc935bc13f243.jpg)

快速排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是 n。

现在只要求出递归树的高度 h，就可以得到时间复杂度 O(h ∗ n)。

我们知道，快速排序结束的条件是待排序的小区间，大小为 1，也就是说叶子节点里的数据规模是 1。

从根节点 n 到叶子节点 1，递归树中最短的一个路径每次都乘以 1 / 10​，最长的一个路径每次都乘以 9 / 10​。通过计算可以得到，从根节点到叶子节点的最短路径是 log10(​n)（10 为底数），最长的路径是 log(10/9)​​(n)（10/9 为底数）。

![路径](@imgs/7cea8607f0d92a901f3152341830d6ed.jpg)

即遍历数据的个数总的范围为 [n * log10(​n), n * log(10/9)(​​n)]。根据复杂度的大 O 表示法，对数复杂度的底数不管是多少，我们统一写成 logn，所以快速排序的平均情况时间复杂度是 O(nlogn)。

### 斐波那契数列时间复杂度

下面这段代码的时间复杂度是多少？如何分析？

```ts
function f(n: number) {
  if (n === 1) return 1;
  if (n === 2) return 2;

  return f(n - 1) + f(n - 2);
}
```

上面的代码画成递归树就是如图：

![递归树](@imgs/9ccbce1a70c7e2def52701dcf176a4ce.jpg)

这棵递归树的高度是多少？

f(n) 分解为 f(n−1) 和 f(n−2)，每次数据规模都是 −1 或者 −2，叶子节点的数据规模是 1 或者 2。

所以，从根节点走到叶子节点，每条路径是长短不一的。如果每次都是 −1，那最长路径大约就是 n；如果每次都是 −2，那最短路径大约就是 n / 2​。

每次分解之后的合并操作只需要一次加法运算，把这次加法运算的时间消耗记作 1。所以，从上往下，第一层的总时间消耗是 1，第二层的总时间消耗是 2，第三层的总时间消耗就是 22。依次类推，第 k 层的时间消耗就是 2k − 1，那整个算法的总的时间消耗就是每一层时间消耗之和：

- 如果路径长度都为 n，那这个总和就是 2n − 1
- 如果路径长度都是 2n​ ，那整个算法的总的时间消耗就是 2 ^ (n / 2)​ − 1

所以这个算法的时间复杂度就介于 O(2 ^ n) 和 O(2 ^ (n / 2)​) 之间。虽然这样得到的结果还不够精确，只是一个范围，但是基本上知道了上面算法的时间复杂度是指数级的，非常高。

### 分析全排列的时间复杂度

全排列的问题：把 n 个数据的所有排列都找出来。比如 1，2，3 这样 3 个数据，有下面这几种不同的排列：

```
1, 2, 3
1, 3, 2
2, 1, 3
2, 3, 1
3, 1, 2
3, 2, 1
```

如果确定了最后一位数据，那就变成了求解剩下 n−1 个数据的排列问题。而最后一位数据可以是 n 个数据中的任意一个，因此它的取值就有 n 种情况。所以，“n 个数据的排列”问题，就可以分解成 n 个“n−1 个数据的排列”的子问题。递推公式：

```
假设数组中存储的是1，2， 3...n。

f(1,2,...n) = {最后一位是1, f(n-1)} + {最后一位是2, f(n-1)} +...+{最后一位是n, f(n-1)}。
```

翻译成代码：

<!-- TODO 代码 -->

画出的递归树如图（已经不是标准的二叉树了）：

![全排列的递归树](@imgs/82f40bed489cf29b14192b44decf059b.jpg)

- 第一层分解有 n 次交换操作
- 第二层有 n 个节点，每个节点分解需要 n − 1 次交换，所以第二层总的交换次数是 n ∗ (n−1)
- 第三层有 n ∗ (n−1) 个节点，每个节点分解需要 n − 2 次交换，所以第三层总的交换次数是 n ∗ (n−1) ∗ (n−2)
- ...
- 以此类推，第 k 层总的交换次数就是 n ∗ (n−1) ∗ (n−2) ∗ ... ∗ (n−k+1)
- 最后一层的交换次数就是 n ∗ (n−1) ∗ (n−2) ∗ ... ∗ 2 ∗ 1

每一层的交换次数之和就是总的交换次数：

```
n + n * (n-1) + n * (n-1) * (n-2) + ... + n * (n-1) * (n-2) * ... * 2 * 1
```

看一下最后一个数，n * (n-1) * (n-2) * ... * 2 * 1 等于 n!，而前面的 n−1 个数都小于最后一个数，所以，总和肯定小于 n ∗ n!，也就是说，全排列的递归算法的时间复杂度大于 O(n!)，小于 O(n ∗ n!)，虽然没法知道非常精确的时间复杂度，但是这样一个范围已经说明了，全排列的时间复杂度是非常高的。

## 思考

1 个细胞的生命周期是 3 小时，1 小时分裂一次。求 n 小时后，容器内有多少细胞？请你用已经学过的递归时间复杂度的分析方法，分析一下这个递归问题的时间复杂度。