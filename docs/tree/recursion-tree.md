# 递归树

<!-- TODO -->
递归树：用于分析递归算法的时间复杂度。在[排序]()部分，我们利用递推公式也可以求解时间复杂度，但是有些情况递推公式并不合适，比如分析[快排]()的平均情况时间复杂度。

## 递归树与时间复杂度分析

递归的思想是：将大问题分解为小问题求解。

把这一层层的分解过程画成图，它就是一棵树 -- 递归树。如图所示是斐波那契数列的递归树：

![斐波那契数列的递归树](@imgs/1d9648b7f43e430473d76d24803159a3.jpg)

那么如何用递归树来分析时间复杂度呢？

以归并排序为例，来看一下如何用递归树来分析递归代码的时间复杂度。

- 首先把归并排序画成递归树：

![归并排序的递归树](@imgs/c66bfc3d02d3b7b8f64c208bf4c948d0.jpg)

每次分解都是一分为二，代价很低，把时间上的消耗记为常量 1。

- 对于耗时的归并操作，从图中可以看出，每一层消耗的时间总和是一样的，记为 n。

现在，只需要知道树的高度 h，就可以得到总的时间复杂度 O(n * h)。

从归并排序的递归树，我们可以看出来这是一棵满二叉树，而满二叉树的高度大约是 logn，所以归并排序的时间复杂度就是 O(nlogn)。虽然这里的时间复杂度都是估算的，对树的高度的计算也没有那么精确，但是这并不影响复杂度的计算结果。

## 实战

### 快速排序时间复杂度

用递推公式来求解快速排序的平均时间复杂度非常复杂：

- 在最好情况下，每次分区都能一分为二，这个时候用递推公式 T(n) = 2T(n / 2​) + n，很容易就能推导出时间复杂度是 O(nlogn)
- 假设平均情况下，每次分区之后，两个分区的大小比例为 1 : k。当 k = 9 时，如果用递推公式的方法来求解时间复杂度的话，递推公式就写成 T(n) = T(n / 10​ ) +T(9n/ 10​) + n

通过公式推导时间复杂度的过程非常复杂。那么用递归树来分析快速排序的平均情况时间复杂度，是不是比较简单呢？

![快速排序的递归树](@imgs/44972a3531dae0b7a0ccc935bc13f243.jpg)

快速排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是 n。

现在只要求出递归树的高度 h，就可以得到时间复杂度 O(h ∗ n)。

我们知道，快速排序结束的条件是待排序的小区间，大小为 1，也就是说叶子节点里的数据规模是 1。

从根节点 n 到叶子节点 1，递归树中最短的一个路径每次都乘以 1 / 10​，最长的一个路径每次都乘以 9 / 10​。通过计算可以得到，从根节点到叶子节点的最短路径是 log10(​n)（10 为底数），最长的路径是 log(10/9)​​(n)（10/9 为底数）。

![路径](@imgs/7cea8607f0d92a901f3152341830d6ed.jpg)

即遍历数据的个数总的范围为 [n * log10(​n), n * log(10/9)(​​n)]。根据复杂度的大 O 表示法，对数复杂度的底数不管是多少，我们统一写成 logn，所以快速排序的平均情况时间复杂度是 O(nlogn)。

### 斐波那契数列时间复杂度

<!-- TODO https://time.geekbang.org/column/article/69388 -->
