# 散列（Hash)表

## 原理 - 散列思想

**散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。**

假如有 89 名选手参加学校运动会，为了方便记录成绩，每个选手胸前都会贴上自己的参赛号码，这 89 名选手的编号依次是 1 到 89。

现在我们希望编程实现这样一个功能，通过编号快速找到选手信息。你会怎么做呢？

我们可以把这 89 名选手的信息放在数组里：

- 编号为 1 的选手，我们放到数组中下标为 1 的位置
- 编号为 2 的选手，我们放到数组中下标为 2 的位置
- 以此类推...
- 编号为 k 的选手放到数组中下标为 k 的位置

当需要查询参赛编号为 x 的选手时，只需要将下标为 x 的数组元素取出来就可以了，时间复杂度就是 O(1)。

这是典型的散列思想：

- 键：参赛选手的编号叫作键 key，用来标识一个选手
- 散列函数：把参赛编号转化为数组下标的映射方法就叫作散列（Hash）函数
- 散列值：散列函数计算得到的值就叫作散列（Hash）值（实际上是数组的下标）

## 散列（Hash）函数

### 设计散列函数

- 散列函数计算得到的散列值是一个非负整数，因为数组的下标从 0 开始
- 如果 `key1 == key2`，则 `hash(key1) == hash(key2)`
- 如果 `key1 != key2`，则 `hash(key1) != hash(key2)`

### 散列冲突

`key1 != key2` 时，`hash(key1) == hash(key2)` 被称为散列冲突。

对于一个散列函数而言，散列冲突几乎不可避免，即便是业界著名的 MD5、SHA、CRC 等哈希算法，也无法完全避免散列冲突。而且，因为数组的存储空间有限，也会加大散列冲突的概率。

那么如何解决散列冲突？

## 开放寻址法

核心思想：**如果出现了散列冲突，就重新探测一个空闲位置，将其插入**。那如何重新探测新的位置呢？

### 线性探测

#### 插入操作

往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。

![线性探测](@imgs/5c31a3127cbc00f0c63409bbe1fbd0d5.jpg)

如图，黄色色块表示空闲位置，橙色色块表示已经存储了数据。散列表的大小为 10，在元素 x 插入散列表之前，有 6 个元素已经插入到散列表中：

- x 经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突
- 于是就顺序地往后一个一个找，看有没有空闲的位置，遍历到尾部都没有找到空闲的位置
- 于是再从表头开始找，直到找到空闲位置 2，将其插入到这个位置

#### 删除操作

散列表跟数组一样，还支持删除操作。对于使用线性探测法解决冲突的散列表，删除操作稍微有些特别，**不能单纯地把要删除的元素设置为空**。

因为在查找时，一旦通过线性探测法找到一个空闲位置，就可以认定散列表中不存在这个数据。但是如果这个空闲位置是后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。

将删除的元素，特殊标记为 `deleted`。当线性探测查找的时候，遇到标记为 `deleted` 的空间，并不是停下来，而是继续往下探测。

![线性探测表的删除](@imgs/fe7482ba09670cbe05a9dfe4dd49bd1d.jpg)

#### 不足

线性探测法其实存在很大问题。

当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久，**最坏情况时间复杂度为 O(n)**。

同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。

### 二次探测

线性探测每次探测的步长是 1，那它探测的下标序列就是 `hash(key) + 0`，`hash(key) + 1`，`hash(key) + 2`...

二次探测探测的步长是原来的“二次方”，即它探测的下标序列是 `hash(key) + 0`，`hash(key) + 1 ^ 2`，`hash(key) + 2 ^ 2`...

### 双重散列

双重散列就是使用多个散列函数。

比如使用一组散列函数 `hash1(key)`，`hash2(key)`，`hash3(key)`...

- 先用第一个散列函数
- 如果计算得到的存储位置已经被占用，再用第二个散列函数
- ...
- 依次类推，直到找到空闲的存储位置

### 总结

**不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。**

### 装载因子

装载因子（load factor）用于表示空位的多少。为了尽可能保证散列表的操作效率，需要尽可能保证散列表中有一定比例的空闲槽位。

```
散列表的装载因子 = 填入表中的元素个数 / 散列表的长度
```

装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

## 链表法

一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。

![链表法](@imgs/a4b77d593e4cb76acb2b0689294ec17f.jpg)

如图，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。

当插入的时候，只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。

当查找、删除一个元素时，同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。

那么查找或删除操作的时间复杂度是多少呢？

这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理想情况下 `k = n / m`（n 表示散列中数据的个数，m 表示散列表中“槽”的个数）。

## 思考

### 拼写错误检查

Word 文档中单词拼写检查功能是如何实现的？

常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。

所以可以用散列表来存储整个英文单词词典。

当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找：

- 如果查到，则说明拼写正确；
- 如果没有查到，则说明拼写可能有误，给予提示

借助散列表这种数据结构，轻松实现了快速判断是否存在拼写错误的功能。

### 日志排序问题

假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？

遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 k，时间复杂度 O(n)。

- 如果 k 不是很大，可以使用桶排序，时间复杂度 O(n)
- 如果 k 非常大（比如大于 10 万），就使用快速排序，复杂度 O(nlogn)

### 查找相同字符串

有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？

- 以第一个字符串数组构建散列表，key 为字符串，value 为出现次数
- 遍历第二个字符串数组，以字符串为 key 在散列表中查找
  - 如果 value 大于零，说明存在相同字符串

时间复杂度 O(n)。
