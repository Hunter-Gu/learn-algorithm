# 跳表

因为二分查找底层依赖的是数组随机访问的特性，所以只能用数组来实现。如果数据存储在链表中，就真的没法用二分查找算法了吗？

只需要对链表稍加改造，就可以支持类似“二分”的查找算法，改造之后的数据结构叫作跳表（Skip list）。

跳表是一种各方面性能都比较优秀的动态数据结构，可以支持快速的插入、删除、查找操作，甚至可以替代红黑树（Red-black tree）。

## 原理 - 建立索引

![原始链表](@imgs/e18303fcedc068e5a168de04df956f6d.jpg)

在单链表中查找某个数据，只能从头到尾遍历链表，时间复杂度是 O(n)。如何提高查找效率？

对链表**建立索引**。

![一级索引](@imgs/14753c824a5ee4a976ea799727adc78e.jpg)

如图每两个结点提取一个结点到上一级，抽出来的那一级叫作索引。

如果现在要查找某个结点，比如 16：

- 可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，我们发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间
- 然后通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历

这个时候，我们只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，原来如果要查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点。

加了一层索引之后，查找效率提高了。那如果我们再加一级索引呢？效率会不会提升更多呢？

![二级索引](@imgs/492206afe5e2fef9f683c7cff83afa65.jpg)

此时再查找 16 只需要遍历 6 个结点，查找效率又提高了。

如果数据量比较大，效果会非常明显。比如在一个包含 64 个结点链表中，建立五级索引，查找 62 只需遍历 11 个结点，而原来需要遍历 62 个结点，速度提高非常明显。

**对链表加多级索引的结构**，就是跳表。

## 时间复杂度 - 索引的级数

每两个结点会抽出一个结点作为上一级索引的结点：
- 第一级索引的结点个数大约就是 n/2
- 第二级索引的结点个数大约就是 n/4
- 第三级索引的结点个数大约就是 n/8
- 依次类推...
- 第 k 级索引的结点个数 n/(2^k)

假设最高级的索引有 2 个结点，可以得到 k = log2(n) - 1，那么整个跳表的高度就是 log2(n)。查询时如果每层都要遍历 m 个结点，那么在跳表中查询一个数据的时间复杂度为 O(m * logn)。

那么 m 的值是多少呢？

假设我们要查找的数据是 x：

- 第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引
- 第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 k-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点

所以，m = 3，那么在跳表中查询任意数据的时间复杂度就是 O(logn)，和二分查找的时间复杂度一样。基于单链表实现了二分查找，提升了查找效率，这是用空间换时间的设计思路。

## 空间复杂度

假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点：

```
n/2, n/4, n/8, ..., 2
```

所有层级索引的总结点数为：n/2 + n/4 + n/8 + ... + 8 + 4 + 2 = n - 2，所以跳表的空间复杂度是 O(n)。

所以将包含 n 个结点的单链表构造成跳表，需要额外再用接近 n 个结点的存储空间。那么有没有办法降低索引占用的内存空间呢？

前面是每两个结点抽一个结点到上级索引，如果每三个结点或五个结点，抽一个结点到上级索引，是不是就不用那么多索引结点了呢？

![三个节点间隔的索引](@imgs/0b0680ecf500f9349fc142e1a9eb73f7.jpg)

- 第一级索引需要大约 n/3 个结点
- 第二级索引需要大约 n/9 个结点
- 每往上一级，索引结点个数都除以 3

为了方便计算，假设最高一级的索引结点个数是 1，同样是等比数列。总的索引结点大约就是：n / 3 + n / 9 + n / 27 + ... + 9 + 3 + 1 = n / 2。

尽管空间复杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。

实际开发中，不必太在意索引占用的额外空间。因为实际开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。

## 高效的动态插入和删除

表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)。

### 插入

在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是 O(1)。但是为了保证原始链表中数据的有序性，我们需要先找到要插入的位置，这个查找操作就会比较耗时。

- 纯粹的单链表，需要遍历每个结点，来找到插入的位置
- 对于跳表来说，查找某个结点的的时间复杂度是 O(logn)，所以插入操作的时间复杂度也是 O(logn)

### 删除

如果要删除的结点在索引中也有出现，除了要删除原始链表中的结点，还要删除索引中的。

单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。除非用的是双向链表，就不需要考虑这个问题了。

## 索引动态更新 - 随机函数

不停地往跳表中插入数据时，如果不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。

作为一种动态数据结构，需要某种手段来维护索引与原始链表大小之间的平衡。如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。

通过**随机函数**来维护跳表的“平衡性”。

当往跳表中插入数据的时候，可以选择同时将这个数据插入到部分索引层中。那么该如何选择加入哪些索引层呢？

通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 k，那我们就将这个结点添加到第一级到第 k 级 共 k 层索引中。

![随机函数决定索引插入](@imgs/a861445d0b53fc842f38919365b004a7.jpg)

随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。

至于随机函数的选择，可以看看 Redis 中关于有序集合的跳表实现。 TODO

```ts
class SkipList {

}
```

## 思考

### Redis 的有序集合

Redis 中的有序集合（Sorted Set）就是用跳表来实现的，红黑树也可以实现快速的插入、删除和查找操作。那 Redis 为什么会选择用跳表来实现有序集合呢？ 为什么不用红黑树呢？

Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了[散列表](/search/hash-table-and-linked-list.html#redis-有序集合)。如果你去查看 Redis 的开发手册，就会发现，Redis 中的有序集合支持的核心操作主要有下面这几个：

- 插入一个数据
- 删除一个数据
- 查找一个数据
- 按照区间查找数据（比如查找值在[100, 356]之间的数据）
- 迭代输出有序序列

其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。

对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，非常高效。

当然，Redis 之所以用跳表来实现有序集合，还有其他原因：

- 比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错
- 还有，跳表更加灵活。它可以通过改变索引构建策略，有效平衡执行效率和内存消耗
- 不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，不用费劲自己去实现一个红黑树，直接拿来用就可以了；但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。
