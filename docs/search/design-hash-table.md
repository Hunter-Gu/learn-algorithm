# 设计散列表

有些恶意的攻击者，可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。此时如果使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。

如果散列表中有 10 万个数据，退化后的散列表查询的效率就下降了 10 万倍。更直接点说，如果之前运行 100 次查询只需要 0.1 秒，那现在就需要 1 万秒。这样就有可能因为查询操作消耗大量 CPU 或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击（DoS）的目的。这也就是散列表碰撞攻击的基本原理。

## 如何设计散列函数？

散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能。

什么才是好的散列函数呢？

- 散列函数的设计不能太复杂。过于复杂的散列函数，势必会消耗很多计算时间，也就间接的影响到散列表的性能
- 散列函数生成的值要尽可能随机并且均匀分布，这样才能避免或者最小化散列冲突
- 即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况

实际工作中，还需要综合考虑各种因素。这些因素有关键字的长度、特点、分布、还有散列表的大小等。

散列函数各式各样，下面是常用的、简单的散列函数的设计方法。

### 数据分析法

以设计手机号码的散列函数为例，由于手机号码前几位重复的可能性很大，但是后面几位就比较随机，可以取手机号的后四位作为散列值。

### Word 拼写检查功能

这里的散列函数，可以这样设计：

- 将单词中每个字母的 ASCll 码值“进位”相加
- 然后跟散列表的大小求余、取模，作为散列值

比如，英文单词 nice，我们转化出来的散列值就是下面这样：

```
hash("nice") = (
  ("n" - "a") * 26 ^ 3 +
  ("i" - "a") * 26 ^ 2 +
  ("c" - "a") * 26 ^ 1 +
  ("e" - "a") * 26 ^ 0
) / 78978
```

散列函数的设计方法还有：

- 直接寻址法
- 平方取中法
- 折叠法
- 随机数法

## 装载因子过大

### 动态扩容

装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大：

- 插入数据的过程要多次寻址或者拉很长的链
- 查找的过程也会变得很慢

#### 静态数据

对于没有频繁插入和删除的静态数据集合来说，很容易根据数据的特点、分布等，设计出完美的、极少冲突的散列函数，因为毕竟之前数据都是已知的。

#### 动态数据

对于动态散列表来说，数据集合是频繁变动的，事先无法预估将要加入的数据个数，所以也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受。

当装载因子过大时，可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。

假设每次扩容都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4。

针对数组的扩容，数据搬移操作比较简单。但是针对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也变了，所以我们需要**通过散列函数重新计算**每个数据的存储位置。

对于支持动态扩容的散列表，插入操作的时间复杂度是多少呢？

- 最好情况：插入一个数据，不需要扩容，时间复杂度是 O(1)
- 最坏情况：散列表装载因子过高，启动扩容，需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O(n)
- 均摊情况：用平摊分析法分析，平均时间复杂度是 O(1)

### 动态缩容

如果对空间消耗非常敏感，我们可以在装载因子小于某个值之后，启动动态缩容。因为对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了。

当散列表的装载因子超过某个阈值时，就需要进行扩容。装载因子阈值需要选择得当：

- 太大，会导致冲突过多
- 太小，会导致内存浪费严重

装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。

## 如何避免低效地扩容？

大部分情况下，动态扩容的散列表插入一个数据都很快；但是当装载因子已经到达阈值，需要先进行扩容，再插入数据。这个时候，插入数据就会变得很慢，甚至会无法接受。

举个极端的例子，如果散列表当前大小为 1GB，要想扩容为原来的两倍大小，那就需要对 1GB 的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表，听起来就很耗时，是不是？

如果我们的业务代码直接服务于用户，尽管大部分情况下，插入一个数据的操作都很快，但是极个别非常慢的插入操作，也会让用户崩溃。这个时候，“一次性”扩容的机制就不合适了。

为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成：

- 当装载因子触达阈值之后，只申请新空间，并不将老的数据搬移到新散列表中
- 当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表
- 每次插入一个数据到散列表，我们都重复上面的过程
- 经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了

![避免低效扩容](@imgs/6d6736f986ec4b75dabc5472965fb9cb.jpg)

这样没有了集中的一次性数据搬移，插入操作就都变得很快了。

## 如何选择冲突解决方法？

### 开放寻址法

开放寻址法的优点：

- 散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度
- 容易序列化。链表法包含指针，序列化起来就没那么容易。

开放寻址法的缺点：

- 删除数据的时候，需要特殊标记已经删除掉的数据，比较麻烦
- 所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。

**当数据量比较小、装载因子小的时候，适合采用开放寻址法**。这也是 Java 中的 `ThreadLocalMap` 使用开放寻址法解决散列冲突的原因。

### 链表法

链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。

比起开放寻址法，链表法对大装载因子的容忍度更高。

开放寻址法适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。

对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。

对于比较小的对象的存储，由于链表要存储指针，所以是比较消耗内存的，还有可能会让内存的消耗翻倍。而且，因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。

如果存储的是大对象，也就是说要存储的对象的大小远远大于一个指针的大小（4 个字节或者 8 个字节），那链表中指针的内存消耗在大对象面前就可以忽略了。

对链表法稍加改造，可以实现一个更加高效的散列表。将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。这样也就有效避免了前面讲到的散列碰撞攻击。

当存储大对象、大数据量时，使用采用基于链表的散列冲突处理方法。而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。

## Java 中的 `HashMap`

1. 初始大小

`HashMap` 默认的初始大小是 16，这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 `HashMap` 的性能。

2. 装载因子和动态扩容

最大装载因子默认是 0.75，当 `HashMap` 中元素个数超过 0.75 * capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。

3. 散列冲突解决方法

`HashMap` 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 `HashMap` 的性能。

于是，在 JDK1.8 版本中，为了对 `HashMap` 做进一步优化，引入了红黑树：

- 当链表长度太长（默认超过 8）时，链表就转换为红黑树。利用了红黑树快速增删改查的特点，提高 HashMap 的性能
- 当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显

1. 散列函数

散列函数的设计并不复杂，追求的是简单高效、分布均匀：

```java
int hash(Object key) {
    int h = key.hashCode()；
    return (h ^ (h >>> 16)) & (capicity - 1); // capicity 表示散列表的大小
}
```

<!-- 在JDK HashMap 源码中，是分两步走的：
1. hash值的计算，源码如下：
static final int hash(Object key) {
        int hash;
        return key == null ? 0 : (hash = key.hashCode()) ^ hash >>> 16;
 }

2. 在插入或查找的时候，计算Key被映射到桶的位置：
int index = hash(key) & (capacity - 1)

----------------------------
JDK HashMap中hash函数的设计，确实很巧妙：

首先hashcode本身是个32位整型值，在系统中，这个值对于不同的对象必须保证唯一（JAVA规范），这也是大家常说的，重写equals必须重写hashcode的重要原因。

获取对象的hashcode以后，先进行移位运算，然后再和自己做异或运算，即：hashcode ^ (hashcode >>> 16)，这一步甚是巧妙，是将高16位移到低16位，这样计算出来的整型值将“具有”高位和低位的性质

最后，用hash表当前的容量减去一，再和刚刚计算出来的整型值做位与运算。进行位与运算，很好理解，是为了计算出数组中的位置。但这里有个问题：
为什么要用容量减去一？
因为 A % B = A & (B - 1)，所以，(h ^ (h >>> 16)) & (capitity -1) = (h ^ (h >>> 16)) % capitity，可以看出这里本质上是使用了「除留余数法」

综上，可以看出，hashcode的随机性，加上移位异或算法，得到一个非常随机的hash值，再通过「除留余数法」，得到index，整体的设计过程与老师所说的“散列函数”设计原则非常吻合！ -->

其中，`hashCode()` 返回的是 Java 对象的 hash code。比如 `String` 类型的对象的 `hashCode()` 是这样：

```java
public int hashCode() {
  int var1 = this.hash;
  if(var1 == 0 && this.value.length > 0) {
    char[] var2 = this.value;
    for(int var3 = 0; var3 < this.value.length; ++var3) {
      var1 = 31 * var1 + var2[var3];
    }
    this.hash = var1;
  }
  return var1;
}
```

## 问题

### 如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？

首先思考何为一个工业级的散列表？工业级的散列表应该具有哪些特性？

应该有这样几点要求：

- 支持快速的查询、插入、删除操作
- 内存占用合理，不能浪费过多的内存空间
- 性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况

如何实现这样一个散列表呢？

从这些方面来考虑设计思路：

- 设计一个合适的散列函数
- 定义装载因子阈值，并且设计动态扩容策略
- 选择合适的散列冲突解决方法

关于散列函数、装载因子、动态扩容策略，还有散列冲突的解决办法，我们前面都讲过了，具体如何选择，还要结合具体的业务场景、具体的业务数据来具体分析。不过只要我们朝这三个方向努力，就离设计出工业级的散列表不远了。
