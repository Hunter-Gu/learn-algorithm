# 字符串匹配

- 单模式串匹配：一个串跟一个串进行匹配
- 多模式串匹配:在一个串中同时查找多个串

主串和模式串：在字符串 A 中查找字符串 B，那字符串 A 就是主串，字符串 B 就是模式串。把主串的长度记作 n，模式串的长度记作 m。因为是在主串中查找模式串，所以 n > m。

## BF（暴力/朴素匹配）

在主串中，检查起始位置分别是 0、1、2...n-m 且长度为 m 的 n - m + 1 个子串，看有没有跟模式串匹配的。

极端情况下，比如主串是“aaaaa...aaaaaa”（省略号表示有很多重复的字符 a），模式串是“aaaaab”。每次都比对 m 个字符，要比对 n - m + 1 次，所以，这种算法的最坏情况时间复杂度是 O( n * m)。

尽管理论上，BF 算法的时间复杂度很高，是 O(n* m )，但在实际的开发中，它却是一个比较常用的字符串匹配算法。为什么呢？

原因有两点：

- 实际开发中，大部分情况下，模式串和主串的长度都不会太长。且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把 m 个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是 O(n*m)，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。
- KISS（Keep it Simple and Stupid） 设计原则。BF 算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有 bug 也容易暴露和修复。在工程中，在满足性能要求的前提下，简单是首选。

## RK

RK 算法是 BF 算法的升级版。

BF 算法中，如果模式串长度为 m，主串长度为 n，那在主串中，就会有 n - m + 1 个长度为 m 的子串，所以只需要暴力地对比这 n - m + 1 个子串与模式串，就可以找出主串与模式串匹配的子串。

但是，每次检查主串与子串是否匹配，需要依次比对每个字符，所以 BF 算法的时间复杂度就比较高，是 O(n * m)。对 BF 算法稍加改造，引入哈希算法，时间复杂度立刻就会降低。

RK 算法的思路：通过哈希算法对主串中的 n - m + 1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里先不考虑哈希冲突的问题，后面会讲到）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。

![RK](@imgs/015c85a9c2a4adc11236f9a40c6d57ee.jpg)

通过哈希算法计算子串的哈希值的时候，需要遍历子串中的每个字符。尽管模式串与子串比较的效率提高了，但是算法整体的效率并没有提高。

有没有方法可以提高哈希算法计算子串哈希值的效率呢？

这就需要哈希算法设计的非常有技巧了。假设要匹配的字符串的字符集中只包含 K 个字符，我们可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。

表述起来有点抽象，举个例子。比如要处理的字符串只包含 a～z 这 26 个小写字母，那我们就用二十六进制来表示一个字符串。我们把 a～z 这 26 个字符映射到 0～25 这 26 个数字，a 就表示 0，b 就表示 1，以此类推，z 表示 25。在十进制的表示法中，一个数字的值是通过下面的方式计算出来的。对应到二十六进制，一个包含 a 到 z 这 26 个字符的字符串，计算哈希的时候，我们只需要把进位从 10 改成 26 就可以。

![Hash 算法](@imgs/d5c1cb11d9fc97d0b28513ba7495ab04.jpg)

> 为了方便解释，在下面的讲解中，假设字符串中只包含 a～z 这 26 个小写字符，用二十六进制来表示一个字符串，对应的哈希值就是二十六进制数转化成十进制的结果。

这种哈希算法有一个特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系：

![](@imgs/f99c16f2f899d19935567102c59661f5.jpg)

很容易得出例子中的规律：相邻两个子串 s[i - 1] 和 s[i]（i 表示子串在主串中的起始位置，子串的长度都为 m），对应的哈希值计算公式有交集，也就是说，可以使用 s[i - 1] 的哈希值很快的计算出 s[i]的哈希值。如果用公式表示的话，就是下面这个样子：

![](@imgs/c47b092408ebfddfa96268037d53aa9c.jpg)

这里有一个小细节，26 ^ (m - 1) 的计算可以通过查表的方法来提高效率。我们事先计算好 26^0、26^1、26^2...26^(m-1)，并且存储在一个长度为 m 的数组中，公式中的“次方”就对应数组的下标。

![](@imgs/224b899c6e82ec54594e2683acc4552f.jpg)

### 时间复杂度

RK 算法的时间复杂度是多少呢？

- 计算子串哈希值：通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是 O(n)
- 模式串哈希值与子串哈希值之间的比较：模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 O(1)，总共需要比较 n - m + 1 个子串的哈希值，所以这部分的时间复杂度也是 O(n)

所以，RK 算法整体的时间复杂度就是 O(n)。

#### 可接受的 Hash 冲突

这里还有一个问题就是，模式串很长，相应的主串中的子串也会很长，通过上面的哈希算法计算得到的哈希值就可能很大，如果超过了计算机中整型数据可以表示的范围，那该如何解决呢？

刚刚设计的哈希算法是没有散列冲突的，也就是说，一个字符串与一个二十六进制数一一对应，不同的字符串的哈希值肯定不一样。因为是基于进制来表示一个字符串的，所以可以类比成十进制、十六进制来思考一下。

为了能将哈希值落在整型数据范围内，可以牺牲一下，允许哈希冲突。这个时候哈希算法该如何设计呢？

哈希算法的设计方法有很多，举个例子。假设字符串中只包含 a～z 这 26 个英文字母，每个字母对应一个数字，比如 a 对应 1，b 对应 2，以此类推，z 对应 26。可以把字符串中每个字母对应的数字相加，最后得到的和作为哈希值。

这种哈希算法产生的哈希值的数据范围就相对要小很多了。不过这种哈希算法的哈希冲突概率也是挺高的。

#### 处理 Hash 冲突

那现在新的问题来了。之前只需要比较一下模式串和子串的哈希值，如果两个值相等，那这个子串就一定可以匹配模式串。但是，当存在哈希冲突的时候，有可能存在这样的情况，子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。

实际上，解决方法很简单。当发现一个子串的哈希值跟模式串的哈希值相等的时候，只需要再对比一下子串和模式串本身就好了。如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也是不匹配的，就不需要比对子串和模式串本身了。

所以，哈希算法的冲突概率要相对控制得低一些，如果存在大量冲突，就会导致 RK 算法的时间复杂度退化，效率下降。极端情况下，如果存在大量的冲突，每次都要再对比子串和模式串本身，那时间复杂度就会退化成 O(n*m)。但也不要太悲观，一般情况下，冲突不会很多，RK 算法的效率还是比 BF 算法高的。

## BM

### 核心思想

把模式串和主串的匹配过程，看作模式串在主串中不停地往后滑动。

当遇到不匹配的字符时，BF 算法和 RK 算法的做法是，模式串往后滑动一位，然后从模式串的第一个字符开始重新匹配。如图：

![](@imgs/4316dd98eac500a01a0fd632bb5e77f9.jpg)

主串中的 c，在模式串中是不存在的，所以，模式串向后滑动的时候，只要 c 与模式串有重合，肯定无法匹配。所以可以一次性把模式串往后多滑动几位，把模式串移动到 c 的后面。

![](@imgs/cf362f9e59c01aaf40a34d2f10e1ef15.jpg)

当遇到不匹配的字符时，有什么固定的规律，可以将模式串往后多滑动几位呢？这样一次性往后滑动好几位，那匹配的效率岂不是就提高了？

BM 算法本质上其实就是在寻找这种规律。借助这种规律，在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。

### 原理分析

BM 算法包含两部分：

- 坏字符规则（bad character rule）
- 好后缀规则（good suffix shift）

#### 坏字符规则

BM 算法的匹配顺序是按照模式串下标从大到小的顺序，倒着匹配的：

![](@imgs/29521f541dd45e13162013b3364fece1.jpg)

![](@imgs/540809418354024206d9989cb6cdd89e.jpg)

当发现某个字符没法匹配的时候，把这个没有匹配的字符叫作坏字符（主串中的字符）。

![](@imgs/220daef736418df84367215647bca5da.jpg)

拿坏字符 c 在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符 c 与模式串中的任何字符都不可能匹配。

此时可以将模式串直接往后滑动三位，将模式串滑动到 c 后面的位置，再从模式串的末尾字符开始比较。

![](@imgs/4e36c4d48d1b6c3b499fb021f03c7f64.jpg)

此时模式串中最后一个字符 d，还是无法跟主串中的 a 匹配，这个时候，还能将模式串往后滑动三位吗？

答案是不行的。因为这个时候，坏字符 a 在模式串中是存在的，模式串中下标是 0 的位置也是字符 a。这种情况下，可以将模式串往后滑动两位，让两个 a 上下对齐，然后再从模式串的末尾字符开始，重新匹配。

![](@imgs/a8d229aa217a67051fbb31b8aeb2edca.jpg)

第一次不匹配的时候，滑动了三位；第二次不匹配的时候，将模式串后移两位，那具体滑动多少位，到底有没有规律呢？

当发生不匹配的时候，把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，把这个坏字符在模式串中的下标记作 xi。如果不存在，我们把 xi 记作 -1。那模式串往后移动的位数就等于 si-xi。（注意，这里说的下标，都是字符在模式串的下标）。

![](@imgs/8f520fb9d9cec0f6ea641d4181eb432e.jpg)

特别说明一点，如果坏字符在模式串里多处出现，那我们在计算 xi 的时候，选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。

利用坏字符规则，BM 算法在最好情况下的时间复杂度非常低，是 O(n/m)。比如，主串是 aaabaaabaaabaaab，模式串是 aaaa。每次比对，模式串都可以直接后移四位，所以，匹配具有类似特点的模式串和主串的时候，BM 算法非常高效。

不过，单纯使用坏字符规则还是不够的。因为根据 si-xi 计算出来的移动位数，有可能是负数，比如主串是 aaaaaaaaaaaaaaaa，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。所以，BM 算法还需要用到“好后缀规则”。

#### 好后缀规则

好后缀规则跟坏字符规则的思路很类似。

如图，当模式串滑动到图中的位置的时候，模式串和主串有 2 个字符是匹配的，倒数第 3 个字符发生了不匹配的情况。

![](@imgs/d78990dbcb794d1aa2cf4a3c646ae58a.jpg)

这个时候该如何滑动模式串呢？

当然，还可以利用坏字符规则来计算模式串的滑动位数，不过，也可以使用好后缀处理规则。

好后缀规则是怎么工作的？把已经匹配的 bc 叫作好后缀，记作{u}。拿它在模式串中查找，如果找到了另一个跟{u}相匹配的子串{u*}，那就将模式串滑动到子串{u*}与主串中{u}对齐的位置。

![](@imgs/b9785be3e91e34bbc23961f67c234b63.jpg)

如果在模式串中找不到另一个等于{u}的子串，就直接将模式串，滑动到主串中{u}的后面，因为之前的任何一次往后滑动，都没有匹配主串中{u}的情况。

![](@imgs/de97c461b9b9dbc42d35768db59908cd.jpg)

不过，当模式串中不存在等于{u}的子串时，直接将模式串滑动到主串{u}的后面。这样做是否有点太过头呢？

看下面这个例子。这里面 bc 是好后缀，尽管在模式串中没有另外一个相匹配的子串{u*}，但是如果我们将模式串移动到好后缀的后面，如图所示，那就会错过模式串和主串可以匹配的情况。

![](@imgs/9b3fa3d1cd9c0d0f914a9b1f518ad070.jpg)

如果好后缀在模式串中不存在可匹配的子串，那在一步一步往后滑动模式串的过程中，只要主串中的{u}与模式串有重合，那肯定就无法完全匹配。但是当模式串滑动到前缀与主串中{u}的后缀有部分重合的时候，并且重合的部分相等的时候，就有可能会存在完全匹配的情况。

![](@imgs/0544d2997d8bb57c10e13ccac4015e23.jpg)

所以，针对这种情况，不仅要看好后缀在模式串中，是否有另一个匹配的子串，还要考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。

所谓某个字符串 s 的后缀子串，就是最后一个字符跟 s 对齐的子串，比如 abc 的后缀子串就包括 c, bc。所谓前缀子串，就是起始字符跟 s 对齐的子串，比如 abc 的前缀子串有 a，ab。

从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，假设是{v}，然后将模式串滑动到如图所示的位置。

![](@imgs/6caa0f61387fd2b3109fe03d803192f9.jpg)

当模式串和主串中的某个字符不匹配的时候，如何选择用好后缀规则还是坏字符规则，来计算模式串往后滑动的位数？

可以分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数。这种处理方法还可以避免我们前面提到的，根据坏字符规则，计算得到的往后滑动的位数，有可能是负数的情况。

### 代码实现

如何实现 BM 算法？

“坏字符规则”本身不难理解。当遇到坏字符时，要计算往后移动的位数 si-xi，其中 xi 的计算是重点，如何求得 xi 呢？或者说，如何查找坏字符在模式串中出现的位置呢？

如果拿坏字符，在模式串中顺序遍历查找，这样就会比较低效，势必影响这个算法的性能。有没有更加高效的方式呢？

散列表可以派上用场。将模式串中的每个字符及其下标都存到散列表中，这样就可以快速找到坏字符在模式串的位置下标了。关于这个散列表，只实现一种最简单的情况，假设字符串的字符集不是很大，每个字符长度是 1 字节，用大小为 256 的数组，来记录每个字符在模式串中出现的位置。数组的下标对应字符的 ASCII 码值，数组中存储这个字符在模式串中出现的位置。

![](@imgs/bf78f8a0506e069fa318f36c42a95e02.jpg)

## KMP

## 思考

我们今天讲的都是一维字符串的匹配方法，实际上，这两种算法都可以类比到二维空间。假设有下面这样一个二维字符串矩阵（图中的主串），借助今天讲的处理思路，如何在其中查找另一个二维字符串矩阵（图中的模式串）呢？

![](@imgs/00c353326466a8ce4e790e36924704c9.jpg)
