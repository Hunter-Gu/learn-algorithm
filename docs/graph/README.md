# 图

图是一种非线性结构，比树更复杂。

## 是什么

图中的元素叫做顶点（vertex），顶点间的连接关系叫作边（edge）

- 无向图：微信
- 有向图：微博
- 带权图：QQ

### 无向图

微信的好友关系可以用无向图表示。

![无向图](@imgs/df85dc345a9726cab0338e68982fd1af.jpg)

把每个用户看作一个顶点，两个用户之间互加好友，就在两者之间建立一条边。

顶点的度（degree）：跟顶点相连接的边的条数。类似于微信中每个用户有多少个好友。

### 有向图

微博的社交关系可以用有向图表示。微博允许单向关注，用户 A 关注了用户 B，但用户 B 可以不关注用户 A。如果用户 A 关注了用户 B，就在图中画一条从 A 到 B 的带箭头的边，来表示边的方向。

![有向图](@imgs/c31759a37d8a8719841f347bd479b796.jpg)

在有向图中，把度分为：

- 入度（In-degree）：表示有多少条边指向这个顶点。类似于微博中的粉丝数量
- 出度（Out-degree）：表示以顶点为起点，指向其他顶点有多少条边。类似于微博中的关注了多少人

### 带权图

QQ 的好友关系可以用带权图表示。QQ 不仅记录了用户之间的好友关系，还记录了两个用户之间的亲密度，两个用户经常往来，亲密度就比较高。

![带权图](@imgs/55d7e4806dc47950ae098d959b03ace8.jpg)

带权图中，每条边都有一个权重（weight），通过这个权重可以表示 QQ 好友间的亲密度。

## 如何存储

### 邻接矩阵

最直观的存储方式，底层依赖一个二维数组。

- 无向图：如果 i 与 j 之间有边，就将 A[i][j]和 A[j][i] 标记为 1
- 有向图：如果 i 指向 j ，就将 A[i][j] 标记为 1
- 带权图：数组中存储相应的权重

![邻接矩阵](@imgs/625e7493b5470e774b5aa91fb4fdb9d2.jpg)

使用邻接矩阵表示图，好处是简单、直观，但是比较浪费存储空间。

对于无向图来说，如果 A[i][j] 等于 1，那 A[j][i] 也肯定等于 1，实际只需要存储一个就可以了。

另外，如果我们存储的是稀疏图（Sparse Matrix，顶点很多，但每个顶点的边并不多），那邻接矩阵的存储方法就更加浪费空间了。比如微信有好几亿的用户，对应到图上就是好几亿的顶点。每个用户的好友并不会很多，如果用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。

邻接矩阵的存储方法的优点：

- 存储方式简单、直接
- 基于数组，所以获取两个顶点的关系非常高效
- 方便计算。用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算

### 邻接表

邻接表有点类似散列表。每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。

![邻接表](@imgs/039bc254b97bd11670cdc4bf2a8e1394.jpg)

邻接表以时间换空间：

- 邻接矩阵：存储起来比较浪费空间，但是使用起来比较节省时间
- 邻接表： 存储起来比较节省空间，但是使用起来就比较耗时间

图中的例子，如果要确定，是否存在一条从顶点 2 到顶点 4 的边，那我们就要遍历顶点 2 对应的那条链表，看链表中是否存在顶点 4。而且链表的存储方式对缓存不友好。所以在邻接表中查询两个顶点之间的关系不如邻接矩阵高效。

在散列表章节讲到，在基于链表法解决冲突的散列表中，如果链过长，为了提高查找效率，我们可以将链表换成其他更加高效的数据结构，比如平衡二叉查找树等。既然邻接表长得很像散列，当然也可以将邻接表同散列表一样进行“改进升级”。

可以将邻接表中的链表改成平衡二叉查找树。实际开发中，我们可以选择用红黑树（或其他动态数据结构，比如跳表、散列表等），这样就可以更加快速地查找两个顶点之间是否存在边了。

## 思考

### 如何存储微博、微信等这些社交网络的好友关系？

以微博举例。

#### 基本操作

针对微博用户关系，最基本的需要支持下面这样几个操作：

- 判断用户 A 是否关注了用户 B
- 判断用户 A 是否是用户 B 的粉丝
- 用户 A 关注用户 B
- 用户 A 取消关注用户 B
- 根据用户名称的首字母排序，分页获取用户的粉丝列表
- 根据用户名称的首字母排序，分页获取用户的关注列表

#### 如何存储

社交网络是一张稀疏图，采用邻接表来存储。

不过，用一个邻接表来存储这种有向图是不够的。

如果要想知道某个用户都被哪些用户关注了，也就是用户的粉丝列表，是非常困难的，所以就需要一个逆邻接表。

邻接表中存储了用户的关注关系，逆邻接表中存储的是用户的被关注关系：

- 邻接表：  每个顶点的链表中，存储的是这个顶点指向的顶点。用于查找某个用户关注了哪些用户
- 逆邻接表：每个顶点的链表中，存储的是指向这个顶点的顶点。用于查找某个用户被哪些用户关注了

![邻接表 与 逆邻接表](@imgs/501440bcffdcf4e6f9a5ca1117e990a1.jpg)

基础的邻接表不适合快速判断两个用户之间是否是关注与被关注的关系（快速查找），需要进行改进，将邻接表中的链表改为支持快速查找的动态数据结构。

选择哪种动态数据结构呢？红黑树、跳表、有序动态数组还是散列表呢？

如果需要按照用户名称的首字母排序，分页来获取用户的粉丝列表或者关注列表，用跳表这种结构再合适不过了：

- 跳表的插入、删除、查找都非常高效，时间复杂度是 O(logn)，空间复杂度上稍高，是 O(n)
- 最重要的一点，跳表中存储的数据本来就是有序的了，分页获取粉丝列表或关注列表，非常高效

对于小规模的数据，比如社交网络中只有几万、几十万个用户，我们可以将整个社交关系存储在内存中，上面的解决思路是没有问题的。但是如果像微博那样有上亿的用户，数据规模太大，我们就无法全部存储在内存中了。这个时候该怎么办呢？

可以通过哈希算法等数据分片方式，将邻接表存储在不同的机器上。如图，在机器 1 上存储顶点 1，2，3 的邻接表，在机器 2 上，存储顶点 4，5 的邻接表。逆邻接表的处理方式也一样。当要查询顶点与顶点关系的时候，就利用同样的哈希算法，先定位顶点所在的机器，然后再在相应的机器上查找。

![数据分片](@imgs/08e4f4330a1d88e9fec94b0f2d1bbe2f.jpg)

除此之外，还有另外一种解决思路 -- 利用外部存储（比如硬盘），因为外部存储的存储空间要比内存会宽裕很多。

数据库是用来持久化存储关系数据的，这里介绍一种数据库的存储方式。我用下面这张表来存储这样一个图，为了高效地支持前面定义的操作，可以在表上建立多个索引，比如第一列、第二列，给这两列都建立索引。

![](@imgs/7339595c631660dc87559bec2ddf928f.jpg)

### 其他

- 像微信这种无向图，应该怎么存储呢？
- 除了我今天举的社交网络可以用图来表示之外，符合图这种结构特点的例子还有很多，比如知识图谱（Knowledge Graph）。关于图这种数据结构，你还能想到其他生活或者工作中的例子吗？
