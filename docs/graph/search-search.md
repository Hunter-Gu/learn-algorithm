# 字符串匹配

- 单模式串匹配：一个串跟一个串进行匹配
- 多模式串匹配:在一个串中同时查找多个串

主串和模式串：在字符串 A 中查找字符串 B，那字符串 A 就是主串，字符串 B 就是模式串。把主串的长度记作 n，模式串的长度记作 m。因为是在主串中查找模式串，所以 n > m。

## BF（暴力/朴素匹配）

在主串中，检查起始位置分别是 0、1、2...n-m 且长度为 m 的 n - m + 1 个子串，看有没有跟模式串匹配的。

极端情况下，比如主串是“aaaaa...aaaaaa”（省略号表示有很多重复的字符 a），模式串是“aaaaab”。每次都比对 m 个字符，要比对 n - m + 1 次，所以，这种算法的最坏情况时间复杂度是 O( n * m)。

尽管理论上，BF 算法的时间复杂度很高，是 O(n* m )，但在实际的开发中，它却是一个比较常用的字符串匹配算法。为什么呢？

原因有两点：

- 实际开发中，大部分情况下，模式串和主串的长度都不会太长。且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把 m 个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是 O(n*m)，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。
- KISS（Keep it Simple and Stupid） 设计原则。BF 算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有 bug 也容易暴露和修复。在工程中，在满足性能要求的前提下，简单是首选。

## RK

RK 算法是 BF 算法的升级版。

BF 算法中，如果模式串长度为 m，主串长度为 n，那在主串中，就会有 n - m + 1 个长度为 m 的子串，所以只需要暴力地对比这 n - m + 1 个子串与模式串，就可以找出主串与模式串匹配的子串。

但是，每次检查主串与子串是否匹配，需要依次比对每个字符，所以 BF 算法的时间复杂度就比较高，是 O(n * m)。对 BF 算法稍加改造，引入哈希算法，时间复杂度立刻就会降低。

RK 算法的思路：通过哈希算法对主串中的 n - m + 1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里先不考虑哈希冲突的问题，后面会讲到）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。

![RK](@imgs/015c85a9c2a4adc11236f9a40c6d57ee.jpg)

通过哈希算法计算子串的哈希值的时候，需要遍历子串中的每个字符。尽管模式串与子串比较的效率提高了，但是算法整体的效率并没有提高。

有没有方法可以提高哈希算法计算子串哈希值的效率呢？

这就需要哈希算法设计的非常有技巧了。假设要匹配的字符串的字符集中只包含 K 个字符，我们可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。

表述起来有点抽象，举个例子。比如要处理的字符串只包含 a～z 这 26 个小写字母，那我们就用二十六进制来表示一个字符串。我们把 a～z 这 26 个字符映射到 0～25 这 26 个数字，a 就表示 0，b 就表示 1，以此类推，z 表示 25。在十进制的表示法中，一个数字的值是通过下面的方式计算出来的。对应到二十六进制，一个包含 a 到 z 这 26 个字符的字符串，计算哈希的时候，我们只需要把进位从 10 改成 26 就可以。

![Hash 算法](@imgs/d5c1cb11d9fc97d0b28513ba7495ab04.jpg)

> 为了方便解释，在下面的讲解中，假设字符串中只包含 a～z 这 26 个小写字符，用二十六进制来表示一个字符串，对应的哈希值就是二十六进制数转化成十进制的结果。

这种哈希算法有一个特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系：

![](@imgs/f99c16f2f899d19935567102c59661f5.jpg)

很容易得出例子中的规律：相邻两个子串 s[i - 1] 和 s[i]（i 表示子串在主串中的起始位置，子串的长度都为 m），对应的哈希值计算公式有交集，也就是说，可以使用 s[i - 1] 的哈希值很快的计算出 s[i]的哈希值。如果用公式表示的话，就是下面这个样子：

![](@imgs/c47b092408ebfddfa96268037d53aa9c.jpg)

## BM

## KMP
